{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"Editor/GT-C-Editor-About/","title":"\ud83e\udde9 About this Module \ud83e\udde9","text":"Short Description <p>Gorgeous Core is a versatile Unreal Engine plugin that enhances the Unreal Engine editor by providing tools for streamlined structure editing.</p> Long Description <p>Gorgeous Core Editor is designed to be a fundamental building block for Unreal Engine projects, offering a collection of essential tools and utilities that address common development challenges. This plugin simplifies complex tasks and promotes best practices, allowing developers to focus on creating compelling gameplay experiences.</p> <p>The Editor module focuses on enhancing the editor experience:</p> <ul> <li>Functional Structures:<ul> <li>Provides a subsystem for registering functional structures, enabling them to receive <code>PostEditChangeProperty</code> and <code>PreEditChangeProperty</code> events. This gives developers tighter control over how structure properties are edited within the Unreal Engine editor.</li> </ul> </li> </ul>"},{"location":"Editor/GT-C-Editor-About/#integration","title":"\ud83d\udee0\ufe0f Integration","text":"<p>To integrate Gorgeous Core Editor into your project, simply add the plugin to your project's Plugins directory.  Then, you can utilize the provided classes and functions in your C++ code. For example:</p> <pre><code>// Example usage\n#include \"GorgeousCoreEditorMinimalShared.h\"\n// ... your code ...\n</code></pre>"},{"location":"Editor/GT-C-Editor-About/#configuration-c-only","title":"\u2699\ufe0f Configuration (C++ only)","text":"<p>To configure Gorgeous Core, you need to add \"GorgeousCoreEditor\" to the PublicDependencyModuleNames/PrivateDependencyModuleNames array in your project's Build.cs file. This ensures that your project can access the necessary editor components.</p> <pre><code>PublicDependencyModuleNames.AddRange(new string[] { \"GorgeousCoreEditor\" });\nPrivateDependencyModuleNames.AddRange(new string[] { \"GorgeousCoreEditor\" });\n</code></pre>"},{"location":"Editor/GT-C-Editor-About/#frequently-asked-questions-faq","title":"\ud83e\udd14 Frequently Asked Questions (FAQ)","text":"<p>Question: What are Functional Structures in the Editor module?</p> <p>Answer: Functional Structures are a feature that allows developers to receive callbacks when properties of a structure are changed in the Unreal Engine editor. This enables real-time updates and custom behavior when editing structure properties.</p> <p>Question: Why would I use the Editor module?</p> <p>Answer: The Editor module enhances the Unreal Engine editor, providing tools that can streamline content creation workflows and give developers more control over how data is edited and displayed.</p>"},{"location":"EditorUtilities/GT-C-Editor_Utilities-About/","title":"\ud83e\udde9 About this Module \ud83e\udde9","text":"Short Description <p>The Gorgeous Core Editor Utilities module extends the Unreal Editor with custom asset management, factory classes, and utility functions that streamline the creation and management of Gorgeous objects, providing a seamless development experience for plugin users.</p> Long Description <p>The Editor Utilities module is a crucial component of the Gorgeous Core plugin, designed to enhance the Unreal Editor experience for developers working with Gorgeous objects. This module provides specialized tools and utilities that simplify asset creation, management, and customization within the editor environment.</p> <p>The Editor Utilities module offers a collection of tools specifically designed to support the Gorgeous Things plugin family:</p> <ul> <li>Asset Management:<ul> <li>Provides custom asset type actions for Gorgeous objects</li> <li>Implements asset registration and management systems</li> <li>Offers specialized asset creation workflows</li> </ul> </li> <li>Factory Classes:<ul> <li>Includes factory classes for creating various Gorgeous objects</li> <li>Supports custom object creation with appropriate defaults</li> <li>Provides specialized editors for complex object types</li> </ul> </li> <li>Editor Integration:<ul> <li>Extends the editor with custom detail panels</li> <li>Implements property customization for Gorgeous objects</li> <li>Provides specialized visualization tools</li> </ul> </li> <li>Utility Functions:<ul> <li>Contains helper functions for editor-specific tasks</li> <li>Offers tools for asset validation and verification</li> <li>Provides utilities for editor automation</li> </ul> </li> </ul>"},{"location":"EditorUtilities/GT-C-Editor_Utilities-About/#integration","title":"\ud83d\udee0\ufe0f Integration","text":"<p>To integrate the Editor Utilities module into your project, add the plugin to your project's Plugins directory. Then, you can utilize the provided classes and functions in your C++ code. For example:</p> <pre><code>// Example usage\n#include \"GorgeousCoreEditorUtilitiesMinimalShared.h\"\n// ... your code ...\n</code></pre>"},{"location":"EditorUtilities/GT-C-Editor_Utilities-About/#configuration-c-only","title":"\u2699\ufe0f Configuration (C++ only)","text":"<p>To configure the Editor Utilities module, you need to add \"GorgeousCoreEditorUtilities\" to the PrivateDependencyModuleNames array in your project's Build.cs file. This ensures that your project can access the necessary editor components.</p> <pre><code>if (Target.Type == TargetType.Editor) {\n    PrivateDependencyModuleNames.AddRange(new string[] { \"GorgeousCoreEditorUtilities\" });\n}\n</code></pre>"},{"location":"EditorUtilities/GT-C-Editor_Utilities-About/#frequently-asked-questions-faq","title":"\ud83e\udd14 Frequently Asked Questions (FAQ)","text":"<p>Question: What are asset type actions and how do they benefit my workflow?</p> <p>Answer: Asset type actions define how assets appear and behave in the editor. The Editor Utilities module provides custom asset type actions for Gorgeous objects, allowing for specialized context menus, thumbnails, and creation workflows that streamline your development process.</p> <p>Question: How can I create custom factory classes for my Gorgeous objects?</p> <p>Answer: You can create custom factory classes by inheriting from the base factory classes provided by the Editor Utilities module. These factory classes handle the creation of objects with appropriate defaults and provide specialized editors for complex object types.</p> <p>Question: How do I implement custom detail panels for my Gorgeous objects?</p> <p>Answer: The Editor Utilities module provides a framework for creating custom detail panels. You can extend the base detail customization classes to create specialized editors for your Gorgeous objects, allowing for intuitive property editing and visualization.</p>"},{"location":"GorgeousCore/GT-C-About/","title":"\ud83d\udd0e About Gorgeous Core \ud83d\udd0e","text":"Short Description <p>Gorgeous Core is a comprehensive Unreal Engine plugin that provides essential functionality for game development, including object variable management, quality-of-life features, runtime utilities, and editor enhancements to streamline your workflow and enhance your projects.</p> Long Description <p>Gorgeous Core is the foundation of the Gorgeous Things plugin ecosystem, designed to provide developers with powerful tools and utilities that simplify common development tasks. It offers a robust object variable system that allows for flexible data storage and management across different game components, from game instances to player controllers.</p> <p>The plugin is structured into four key modules:</p> <ul> <li> <p>Core Runtime Module:</p> <ul> <li>Defines the base classes and interfaces for the Gorgeous Things ecosystem</li> <li>Implements the object variable system for flexible data management</li> <li>Provides conditional object chooser system for dynamic object selection</li> <li>Supports functional structures with property change events</li> </ul> </li> <li> <p>Runtime Utilities Module:</p> <ul> <li>Offers essential helper functions for file and directory operations</li> <li>Provides comprehensive logging capabilities with different importance levels</li> <li>Includes templates for singleton pattern implementation</li> <li>Contains utility macros for API endpoints and platform-specific code</li> </ul> </li> <li> <p>Editor Module:</p> <ul> <li>Extends the Unreal Editor with custom detail panels</li> <li>Provides factory classes for creating Gorgeous objects</li> <li>Implements functional structure customization</li> <li>Supports detail customization for object variables</li> </ul> </li> <li> <p>Editor Utilities Module:</p> <ul> <li>Handles asset registration and management</li> <li>Provides custom asset type actions</li> <li>Implements factory classes for asset creation</li> <li>Supports editor-specific utility functions</li> </ul> </li> </ul>"},{"location":"GorgeousCore/GT-C-About/#key-features","title":"\ud83d\ude80 Key Features","text":""},{"location":"GorgeousCore/GT-C-About/#object-variable-system","title":"Object Variable System","text":"<ul> <li>Flexible data storage and management across game components</li> <li>Type-safe variable handling with automatic serialization</li> <li>Support for single values, arrays, maps, and sets</li> <li>Integration with Unreal Engine's property system</li> </ul>"},{"location":"GorgeousCore/GT-C-About/#enhanced-game-components","title":"Enhanced Game Components","text":"<ul> <li>Extended versions of core Unreal Engine classes</li> <li>Built-in object variable support</li> <li>Automatic property replication</li> <li>Editor integration for easy configuration</li> </ul>"},{"location":"GorgeousCore/GT-C-About/#conditional-object-chooser-system","title":"Conditional Object Chooser System","text":"<ul> <li>Dynamic object selection based on conditions</li> <li>Support for boolean, validity, and gameplay tag conditions</li> <li>Blueprint-friendly interface</li> <li>Editor tools for condition setup</li> </ul>"},{"location":"GorgeousCore/GT-C-About/#editor-integration","title":"Editor Integration","text":"<ul> <li>Custom detail panels for Gorgeous objects</li> <li>Factory classes for object creation</li> <li>Asset management tools</li> <li>Property customization support</li> </ul>"},{"location":"GorgeousCore/GT-C-About/#comprehensive-logging","title":"Comprehensive Logging","text":"<ul> <li>Multiple importance levels (Information, Success, Warning, Error, Fatal)</li> <li>On-screen and output log support</li> <li>Configurable display duration</li> <li>Category-based filtering</li> </ul>"},{"location":"GorgeousCore/GT-C-About/#file-and-directory-operations","title":"File and Directory Operations","text":"<ul> <li>Simplified file management</li> <li>Directory handling utilities</li> <li>Platform-independent operations</li> <li>Error handling and validation</li> </ul>"},{"location":"GorgeousCore/GT-C-About/#integration","title":"\ud83d\udee0\ufe0f Integration","text":"<p>To integrate Gorgeous Core into your project:</p> <ol> <li>Add the plugin to your project's Plugins directory</li> <li>Include the appropriate headers:</li> </ol> <pre><code>// For Runtime features\n#include \"GorgeousCoreMinimalShared.h\"\n#include \"GorgeousCoreRuntimeUtilitiesMinimalShared.h\"\n\n// For Editor features\n#include \"GorgeousCoreEditorMinimalShared.h\"\n#include \"GorgeousCoreEditorUtilitiesMinimalShared.h\"\n</code></pre>"},{"location":"GorgeousCore/GT-C-About/#configuration","title":"\u2699\ufe0f Configuration","text":"<p>Add the required modules to your project's Build.cs file:</p> <pre><code>// For Runtime features\nPublicDependencyModuleNames.AddRange(new string[] { \n    \"GorgeousCoreRuntime\",\n    \"GorgeousCoreRuntimeUtilities\"\n});\n\n// For Editor features\nif (Target.Type == TargetType.Editor) {\n    PrivateDependencyModuleNames.AddRange(new string[] {\n        \"GorgeousCoreEditor\",\n        \"GorgeousCoreEditorUtilities\"\n    });\n}\n</code></pre>"},{"location":"GorgeousCore/GT-C-About/#frequently-asked-questions-faq","title":"\ud83e\udd14 Frequently Asked Questions (FAQ)","text":"<p>Q: What is the object variable system? A: The object variable system is a flexible data storage mechanism that allows you to attach named variables to various game components. It supports different variable types, provides type safety, automatic serialization, and network replication.</p> <p>Q: How do I access Gorgeous game components? A: You can access Gorgeous components using the standard Unreal Engine casting functions or through the provided global access functions. For example: <pre><code>if (auto* GorgeousGameInstance = Cast&lt;UGorgeousGameInstance&gt;(GetGameInstance()))\n{\n    // Work with the Gorgeous Game Instance\n}\n</code></pre></p> <p>Q: Can I use Gorgeous Core with Blueprints? A: Yes, most features are fully Blueprint-compatible. The object variable system, conditional object choosers, and logging functions are all exposed to Blueprints.</p> <p>Q: How do I create custom object variables? A: You can create custom object variables by: 1. Creating a new class that inherits from <code>UGorgeousObjectVariable</code> 2. Implementing the required functions 3. Using the provided factory in the editor or creating instances in code</p> <p>Q: How do I use the conditional object chooser system? A: The conditional object chooser system allows you to: 1. Create condition objects (Boolean, Validity, or Gameplay Tag) 2. Set up a conditional object chooser with your conditions 3. Configure the objects to be selected based on the conditions 4. Use the chooser to dynamically select objects at runtime</p>"},{"location":"GorgeousCore/GT-C-Patchnotes/","title":"\ud83c\udd95 Patchnotes \ud83c\udd95","text":""},{"location":"GorgeousCore/GT-C-Patchnotes/#gorgeous-core-v08","title":"Gorgeous Core v0.8","text":""},{"location":"GorgeousCore/GT-C-Patchnotes/#new-features","title":"\ud83d\ude80 New Features","text":"<ul> <li>Quality of Life Features</li> <li>Added enhanced game components with object variable capabilities</li> <li>Implemented persistent data storage across game sessions</li> <li> <p>Added support for game instance, game mode, game state, player controller, player state, and world settings extensions</p> </li> <li> <p>Documentation Improvements</p> </li> <li>Complete overhaul of documentation system</li> <li>Added comprehensive README.md with detailed plugin information</li> <li>Created detailed technical documentation with architecture diagrams</li> <li>Implemented MkDocs-based documentation site with custom domain</li> </ul>"},{"location":"GorgeousCore/GT-C-Patchnotes/#improvements","title":"\ud83d\udee0\ufe0f Improvements","text":"<ul> <li>Build System</li> <li>Fixed project packaging issues</li> <li>Added platform blacklist for better compatibility</li> <li> <p>Improved module dependency management</p> </li> <li> <p>Editor Integration</p> </li> <li>Enhanced asset registration system</li> <li>Improved factory classes for object creation</li> <li> <p>Added custom detail panels for better property editing</p> </li> <li> <p>Runtime Utilities</p> </li> <li>Enhanced file and directory operations</li> <li>Improved logging system with multiple importance levels</li> <li>Added templates for singleton pattern implementation</li> </ul>"},{"location":"GorgeousCore/GT-C-Patchnotes/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Fixed documentation index redirection to plugin about page</li> <li>Resolved project packaging issues</li> <li>Fixed README.md links and formatting</li> <li>Corrected markdown links throughout documentation</li> <li>Fixed CONSTRIBUTING.md formatting and section links</li> </ul>"},{"location":"GorgeousCore/GT-C-Patchnotes/#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>New Documentation Files</li> <li>Added DEVELOPMENT.md with development guidelines</li> <li>Created CODE_OF_CONDUCT.md with community guidelines</li> <li>Added CONTRIBUTING.md with contribution guidelines</li> <li> <p>Implemented bug_report.md, feature_request.md, and question.md templates</p> </li> <li> <p>Documentation Structure</p> </li> <li>Organized documentation into logical sections</li> <li>Added detailed technical diagrams</li> <li>Improved navigation and readability</li> <li>Added code examples and usage patterns</li> </ul>"},{"location":"GorgeousCore/GT-C-Patchnotes/#technical-details","title":"\ud83d\udd27 Technical Details","text":"<ul> <li>Architecture</li> <li>Refined modular architecture with four main components:<ul> <li>Core Runtime Module</li> <li>Runtime Utilities Module</li> <li>Editor Module</li> <li>Editor Utilities Module</li> </ul> </li> <li>Improved class hierarchy and relationships</li> <li> <p>Enhanced object variable system</p> </li> <li> <p>Build System</p> </li> <li>Updated CI/CD pipeline</li> <li>Improved documentation build process</li> <li>Added platform-specific configurations</li> </ul>"},{"location":"GorgeousCore/GT-C-Patchnotes/#known-issues","title":"\ud83d\udccb Known Issues","text":"<ul> <li>Some platforms may require additional configuration</li> <li>Documentation site may have temporary redirect issues during deployment</li> </ul>"},{"location":"GorgeousCore/GT-C-Patchnotes/#future-plans","title":"\ud83d\udd1c Future Plans","text":"<ul> <li>Object Variable System Enhancements</li> <li>Custom Details Customization for object variables</li> <li>Improved default value appearance with dropdown menus for type and count</li> <li>Implementation of variable identifier using FGuid</li> <li>Universal Get and Set functions for C++ using template arguments</li> <li>Ability to save object variables to disk via serialization</li> <li>Support for nesting object variables with parent-child relationships</li> <li>Visualization of nested variables in a dedicated window (gorgeous.ov.list)</li> <li>Implementation of persistent and non-persistent variables</li> <li> <p>Automatic cleanup of non-persistent variables after level switches</p> </li> <li> <p>Functional Structures</p> </li> <li>Enhanced structures with PostEditPropertyChange functionality</li> <li>Improved property change callbacks for structure members</li> <li> <p>Better integration with the editor's property system</p> </li> <li> <p>Conditional Object Choosers</p> </li> <li>Implementation of condition-based object selection</li> <li>Support for various condition types (Gameplay Tags, validity checks)</li> <li>Branching logic based on condition results</li> <li> <p>Integration with the object variable system</p> </li> <li> <p>Build System Improvements</p> </li> <li>Internal Build.cs simplification tool</li> <li>Internal Target.cs simplification tool</li> <li>Automatic module dependency scanning and inclusion</li> <li>Support for third-party library integration</li> <li> <p>Enhanced development workflow for both Gorgeous plugins and standalone projects</p> </li> <li> <p>Documentation and Examples</p> </li> <li>Expanded documentation with more detailed examples</li> <li>Tutorial content for common use cases</li> <li>Performance optimization guides</li> <li>Best practices for plugin integration</li> </ul> <p>For detailed information about specific changes, please refer to the GitHub commit history.</p>"},{"location":"GorgeousCore/GT-C-Technical/","title":"\ud83d\udee0\ufe0f Technical \ud83d\udee0\ufe0f","text":"Short Description <p>Gorgeous Core is built on a modular architecture with four main components: Core Runtime, Runtime Utilities, Editor, and Editor Utilities. This technical documentation provides an overview of the architecture, class hierarchy, and key systems.</p> Long Description <p>The technical architecture of Gorgeous Core is designed to be modular, extensible, and efficient. It consists of four main modules that work together to provide a comprehensive set of tools and utilities for Unreal Engine development. This document explains the architecture, class hierarchy, and key systems in detail.</p>"},{"location":"GorgeousCore/GT-C-Technical/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<p>The Gorgeous Core plugin is structured into four main modules, split between core and utility modules:</p>"},{"location":"GorgeousCore/GT-C-Technical/#core-modules","title":"Core Modules","text":"<pre><code>graph TD\n    A[Gorgeous Core] --&gt; B[Core Runtime Module]\n    A --&gt; D[Editor Module]\n\n    B --&gt; B1[Object Variables]\n    B --&gt; B2[Conditional Objects]\n    B --&gt; B3[Functional Structures]\n    B --&gt; B4[Base Classes]\n\n    D --&gt; D1[Detail Panels]\n    D --&gt; D2[Factory Classes]\n    D --&gt; D3[Property Customization]\n    D --&gt; D4[Editor Integration]</code></pre>"},{"location":"GorgeousCore/GT-C-Technical/#utility-modules","title":"Utility Modules","text":"<pre><code>graph TD\n    A[Gorgeous Core] --&gt; C[Runtime Utilities Module]\n    A --&gt; E[Editor Utilities Module]\n\n    C --&gt; C1[File Helpers]\n    C --&gt; C2[Directory Helpers]\n    C --&gt; C3[Logging System]\n    C --&gt; C4[Templates]\n\n    E --&gt; E1[Asset Registration]\n    E --&gt; E2[Asset Type Actions]\n    E --&gt; E3[Asset Factories]\n    E --&gt; E4[Editor Utilities]</code></pre>"},{"location":"GorgeousCore/GT-C-Technical/#module-structure","title":"\ud83d\udd04 Module Structure","text":""},{"location":"GorgeousCore/GT-C-Technical/#core-runtime-module","title":"Core Runtime Module","text":"<pre><code>classDiagram\n    class UGorgeousObjectVariable {\n        +FName UniqueIdentifier\n        +TMap~FName, UGorgeousObjectVariable*~ VariableRegistry\n    }\n\n    class UGorgeousConditionalObjectChooser {\n        +TArray~UGorgeousCondition*~ Conditions\n        +UGorgeousCondition* ConditionCheck\n        +UGorgeousObjectVariable* DecideCondition()\n    }\n\n    class UGorgeousCondition {\n        +uint8 CheckCondition()\n    }\n\n    UGorgeousConditionalObjectChooser &lt;|-- UGorgeousCondition\n    UGorgeousObjectVariable &lt;|-- UGorgeousRootObjectVariable\n    UGorgeousCondition &lt;|-- UGorgeousBooleanCondition\n    UGorgeousCondition &lt;|-- UGorgeousIsValidCondition\n    UGorgeousCondition &lt;|-- UGorgeousGameplayTagCondition</code></pre>"},{"location":"GorgeousCore/GT-C-Technical/#editor-module","title":"Editor Module","text":"<pre><code>classDiagram\n    class FGorgeousObjectVariableDetailCustomization {\n    }\n\n    class FGorgeousFunctionalStructureDetailCustomisation {\n    }\n\n    class UGorgeousFactory {\n    }\n\n    UFactory &lt;|-- UGorgeousFactory\n    UGorgeousFactory &lt;|-- UGorgeousObjectVariableFactory\n    UGorgeousFactory &lt;|-- UGorgeousGameModeFactory\n    UGorgeousFactory &lt;|-- UGorgeousGameStateFactory\n    UGorgeousFactory &lt;|-- UGorgeousXXXFactory</code></pre>"},{"location":"GorgeousCore/GT-C-Technical/#editor-utilities-module","title":"Editor Utilities Module","text":"<pre><code>classDiagram\n    class UGorgeousAssetRegistration_ES {\n        +void RegisterNewAsset()\n        +void RegisterNewCategory()\n    }\n\n    class FGorgeousAssetTypeAction {\n    }\n\n    class UGorgeousFactory {\n        +virtual UObject* FactoryCreateNew() override\n    }\n\n    FAssetTypeActions_Base &lt;|-- FGorgeousAssetTypeAction\n    UFactory &lt;|-- UGorgeousFactory</code></pre>"},{"location":"GorgeousCore/GT-C-Technical/#implementation-details","title":"\ud83d\udcdd Implementation Details","text":""},{"location":"GorgeousCore/GT-C-Technical/#object-variable-system","title":"Object Variable System","text":"<p>The object variable system uses a hierarchical structure: <pre><code>graph TD\n    A[Root Object Variable] --&gt; B[Game Instance Variables]\n    A --&gt; C[Game Mode Variables]\n    A --&gt; D[Game State Variables]\n    B --&gt; B1[Player Variables]\n    B --&gt; B2[Level Variables]\n    C --&gt; C1[Gameplay Variables]\n    D --&gt; D1[Replicated Variables]</code></pre></p>"},{"location":"GorgeousCore/GT-C-Technical/#factory-system","title":"Factory System","text":"<p>The factory system for creating Gorgeous objects: <pre><code>graph LR\n    A[Editor Module] --&gt; B[Factory Base Class]\n    B --&gt; C[Object Variable Factory]\n    B --&gt; D[Game Component Factories]\n    B --&gt; E[Condition Factories]\n\n    D --&gt; D1[Game Mode Factory]\n    D --&gt; D2[Game State Factory]\n    D --&gt; D3[Player Controller Factory]\n\n    E --&gt; E1[Boolean Condition Factory]\n    E --&gt; E2[Is Valid Condition Factory]\n    E --&gt; E3[Gameplay Tag Factory]</code></pre></p>"},{"location":"GorgeousCore/GT-C-Technical/#asset-registration","title":"Asset Registration","text":"<p>The asset registration system: <pre><code>sequenceDiagram\n    participant Editor as Editor Module\n    participant Registry as Asset Registry\n    participant Factory as Asset Factory\n\n    Editor-&gt;&gt;Registry: Register Asset Type\n    Registry-&gt;&gt;Factory: Create Factory Instance\n    Factory-&gt;&gt;Registry: Register Factory\n    Registry-&gt;&gt;Editor: Confirm Registration</code></pre></p>"},{"location":"GorgeousCore/GT-C-Technical/#build-system","title":"\ud83d\udd27 Build System","text":"<p>The module dependencies are managed through Build.cs files:</p> <pre><code>graph TD\n    A[Project] --&gt; B[GorgeousCoreRuntime]\n    A --&gt; C[GorgeousCoreRuntimeUtilities]\n    A --&gt; D[GorgeousCoreEditor]\n    A --&gt; E[GorgeousCoreEditorUtilities]\n\n    B --&gt; F[Core]\n    B --&gt; G[CoreUObject]\n\n    C --&gt; B\n    C --&gt; H[Engine]\n\n    D --&gt; B\n    D --&gt; C\n    D --&gt; I[UnrealEd]\n\n    E --&gt; D\n    E --&gt; J[AssetTools]</code></pre>"},{"location":"GorgeousCore/GT-C-Technical/#key-classes-and-interfaces","title":"\ud83d\udd0d Key Classes and Interfaces","text":""},{"location":"GorgeousCore/GT-C-Technical/#core-runtime","title":"Core Runtime","text":"<ul> <li><code>UGorgeousObjectVariable</code>: Base class for all object variables</li> <li><code>UGorgeousConditionalObjectChooser</code>: Handles dynamic object selection</li> <li><code>UGorgeousCondition</code>: Base class for all conditions</li> </ul>"},{"location":"GorgeousCore/GT-C-Technical/#editor","title":"Editor","text":"<ul> <li><code>FGorgeousObjectVariableDetailCustomization</code>: Customizes object variable properties</li> <li><code>FGorgeousFunctionalStructureDetailCustomisation</code>: Handles structure property changes</li> <li><code>UGorgeousFactory</code>: Base class for all Gorgeous object factories</li> </ul>"},{"location":"GorgeousCore/GT-C-Technical/#editor-utilities","title":"Editor Utilities","text":"<ul> <li><code>FGorgeousAssetTypeAction</code>: Defines how assets behave in the editor</li> <li><code>FGorgeousAssetRegistration</code>: Handles asset registration and unregistration</li> <li><code>UGorgeousFactory</code>: Creates new Gorgeous assets</li> </ul>"},{"location":"GorgeousCore/GT-C-Technical/#extension-points","title":"\ud83d\udd04 Extension Points","text":"<ol> <li> <p>Custom Object Variables <pre><code>UCLASS()\nclass MYGAME_API UMyCustomVariable : public UGorgeousObjectVariable\n{\n    GENERATED_BODY()\n    // Implementation\n};\n</code></pre></p> </li> <li> <p>Custom Conditions <pre><code>UCLASS()\nclass MYGAME_API UMyCustomCondition : public UGorgeousCondition\n{\n    GENERATED_BODY()\n    // Implementation\n};\n</code></pre></p> </li> <li> <p>Custom Asset Types <pre><code>class FMyCustomAssetTypeAction : public FGorgeousAssetTypeAction\n{\n    // Implementation\n};\n</code></pre></p> </li> </ol>"},{"location":"GorgeousCore/GT-C-Technical/#configuration-options","title":"\ud83d\udd27 Configuration Options","text":"<ol> <li>Build Configuration</li> </ol> <pre><code>public class MyGameModule : ModuleRules\n{\n    public MyGameModule(ReadOnlyTargetRules Target) : base(Target)\n    {\n        PublicDependencyModuleNames.AddRange(new string[] {\n            \"GorgeousCoreRuntime\",\n            \"GorgeousCoreRuntimeUtilities\"\n        });\n\n        if (Target.Type == TargetType.Editor)\n        {\n            PrivateDependencyModuleNames.AddRange(new string[] {\n                \"GorgeousCoreEditor\",\n                \"GorgeousCoreEditorUtilities\"\n            });\n        }\n    }\n}\n</code></pre>"},{"location":"GorgeousCore/GT-C-What_To_Come/","title":"\ud83d\udd2e What's Coming to Gorgeous Core \ud83d\udd2e","text":"Short Description <p>Gorgeous Core is evolving with planned enhancements to its object variable system, functional structures, conditional object choosers, and build tools. These improvements will provide more flexible data management, better editor integration, and streamlined development workflows for Unreal Engine projects.</p> Long Description <p>Gorgeous Core is the foundation of the Gorgeous Things plugin ecosystem, designed to provide essential functionality that will be reused across all plugins in the family. This document outlines the planned features and improvements that will be implemented to consider the core \"finished\" (though it will continue to evolve with future projects to achieve \"Battle Tested\" status).</p> <p>The planned enhancements focus on four key areas:</p> <ul> <li>Object Variable System: A highly dynamic system for addressing variables via pointer references, with improvements to customization, storage, and lifecycle management.</li> <li>Functional Structures: Enhanced capabilities for standard Unreal Engine structures with property change callbacks.</li> <li>Conditional Object Choosers: Flexible object selection based on conditions like gameplay tags and reference validity.</li> <li>Build System: Tools to simplify module development and dependency management.</li> </ul>"},{"location":"GorgeousCore/GT-C-What_To_Come/#planned-features","title":"\ud83c\udfaf Planned Features","text":""},{"location":"GorgeousCore/GT-C-What_To_Come/#object-variable-system-enhancements","title":"Object Variable System Enhancements","text":"<p>The object variable system is a highly dynamic system that provides a way of addressing variables via pointer references. While this dynamism allows for adding new variable types, it also makes implementation challenging and requires deep interaction with the engine's source.</p>"},{"location":"GorgeousCore/GT-C-What_To_Come/#custom-details-customization","title":"Custom Details Customization","text":"<ul> <li>Improved Default Value Appearance</li> <li>Creation of two dropdown menus and one FGuid as the variable identifier</li> <li>Type dropdown: Lists every available object variable (C++ or Blueprint)</li> <li>Count dropdown: Lists properties of the EObjectVariableCount_E enum</li> <li>Warning messages for unimplemented count types</li> <li>Dropdown menus only shown when necessary</li> </ul>"},{"location":"GorgeousCore/GT-C-What_To_Come/#value-management","title":"Value Management","text":"<ul> <li>Default Value Construction</li> <li>Dynamic field construction based on Type and Count</li> <li>Access to object variable defaults</li> <li>Enum-based input type specification</li> </ul>"},{"location":"GorgeousCore/GT-C-What_To_Come/#storage-and-retrieval","title":"Storage and Retrieval","text":"<ul> <li>Outer Access</li> <li>Save values in an extra trunk in the outer</li> <li>Load values from the trunk via property name/signature</li> <li>Enum selection for appropriate default value field</li> </ul>"},{"location":"GorgeousCore/GT-C-What_To_Come/#initialization-and-access","title":"Initialization and Access","text":"<ul> <li>Lazy Initialization</li> <li>Initialize saved values from trunk when accessed</li> <li>Use property name/signature as trunk identifier</li> <li>Direct value return if already initialized</li> </ul>"},{"location":"GorgeousCore/GT-C-What_To_Come/#advanced-features","title":"Advanced Features","text":"<ul> <li>Universal Access Functions</li> <li>Template-based Get and Set functions for C++</li> <li> <p>Type parsing via template arguments</p> </li> <li> <p>Persistence</p> </li> <li>Save object variables to disk via serialization</li> <li> <p>Support for runtime persistence</p> </li> <li> <p>Hierarchical Structure</p> </li> <li>Nesting: Parent-child relationships between variables</li> <li> <p>Visualization in a dedicated window (gorgeous.ov.list)</p> </li> <li> <p>Lifecycle Management</p> </li> <li>Persistent and non-persistent variables</li> <li>Automatic cleanup of non-persistent variables after level switches</li> <li>Persistence based on owner object lifecycle</li> </ul> Info <p>This workflow will replace the structures currently representing default values, addressing memory allocation inefficiencies where the entire memory space is allocated even when only a single value is used.</p>"},{"location":"GorgeousCore/GT-C-What_To_Come/#functional-structures","title":"Functional Structures","text":"<p>Functional Structures enhance the capabilities of standard Unreal Engine structures by providing additional functionality:</p> <ul> <li>Property Change Callbacks</li> <li>Structures with PostEditPropertyChange functionality</li> <li>Callbacks when structure members are changed</li> <li>Improved editor integration</li> </ul> Info <p>This feature will be particularly useful for the dialogue system, allowing for dynamic asset selection based on property changes.</p>"},{"location":"GorgeousCore/GT-C-What_To_Come/#conditional-object-choosers","title":"Conditional Object Choosers","text":"<p>Conditional Object Choosers provide a flexible way to select objects based on conditions:</p> <ul> <li>Condition-Based Selection</li> <li>Objects that return different object variables based on condition checks</li> <li>Support for various condition types:<ul> <li>Gameplay Tag presence in containers</li> <li>Reference validity checks</li> </ul> </li> <li>Branching logic based on condition results (Valid/Not Valid, Present/Not Present)</li> </ul>"},{"location":"GorgeousCore/GT-C-What_To_Come/#build-system-improvements","title":"Build System Improvements","text":"<p>The build system improvements aim to simplify module development:</p> <ul> <li>Dependency Management</li> <li>Automatic scanning of source files for needed module dependencies</li> <li>Automatic inclusion of dependencies in module names array</li> <li> <p>Dynamic link error resolution</p> </li> <li> <p>Development Tools</p> </li> <li>Internal Build.cs simplification tool</li> <li>Internal Target.cs simplification tool</li> <li>Support for third-party library integration</li> </ul> Info <p>These improvements will be available not just for Gorgeous plugins but for any Unreal Engine project, providing a tool that simplifies coding quality while maintaining usability.</p>"},{"location":"GorgeousCore/GT-C-What_To_Come/#implementation-timeline","title":"\ud83d\udee0\ufe0f Implementation Timeline","text":"<p>While specific release dates are not yet determined, the implementation will follow this general order:</p> <p>Phase 1: Core Functionality</p> <ol> <li>Basic object variable system enhancements</li> <li>Initial functional structures implementation</li> <li>Foundation for conditional object choosers</li> </ol> <p>Phase 2: Editor Integration</p> <ol> <li>Custom details customization</li> <li>Improved property editing</li> <li>Visualization tools</li> </ol> <p>Phase 3: Advanced Features</p> <ol> <li>Nesting and persistence</li> <li>Universal access functions</li> <li>Conditional object chooser implementation</li> </ol> <p>Phase 4: Build System</p> <ol> <li>Dependency management tools</li> <li>Build.cs and Target.cs simplification</li> <li>Third-party integration support</li> </ol>"},{"location":"GorgeousCore/GT-C-What_To_Come/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions to help implement these features. If you're interested in contributing:</p> <ol> <li>Check the GitHub repository for open issues</li> <li>Review the CONTRIBUTING.md guidelines</li> <li>Fork the repository and create a feature branch</li> <li>Submit a pull request with your changes</li> </ol>"},{"location":"GorgeousCore/GT-C-What_To_Come/#frequently-asked-questions-faq","title":"\ud83e\udd14 Frequently Asked Questions (FAQ)","text":"<p>Q: When will these features be available? A: The implementation will follow the phased approach outlined in the Implementation Timeline section. While specific release dates are not yet determined, we aim to prioritize features based on community feedback and development resources.</p> <p>Q: How can I stay updated on development progress? A: You can follow the GitHub repository for commit updates, check the Issues page for tracking, and join our community discussions for the latest information.</p> <p>Q: Can I contribute to the development of these features? A: Yes! We welcome contributions from the community. You can help by implementing features, providing feedback, or reporting issues. See the Contributing section for more details.</p> <p>Q: Will these changes be backward compatible? A: We aim to maintain backward compatibility where possible. However, some enhancements may require updates to existing code. We will provide migration guides when necessary.</p> <p>Q: How can I provide feedback on these planned features? A: You can provide feedback by opening an issue on the GitHub repository, joining our community discussions, or contacting the development team directly.</p> <p>This roadmap is subject to change as development progresses and new requirements are identified.</p>"},{"location":"Runtime/GT-C-Runtime-About/","title":"\ud83e\udde9 About this Module \ud83e\udde9","text":"Short Description <p>Gorgeous Core is a versatile Unreal Engine plugin that provides essential runtime tools for object variable management, conditional logic, and structure enhancements, simplifying development and promoting organized, efficient code.</p> Long Description <p>Gorgeous Core is designed to be a fundamental building block for Unreal Engine projects, offering a collection of essential tools and utilities that address common development challenges. This plugin simplifies complex tasks and promotes best practices, allowing developers to focus on creating compelling gameplay experiences.</p> <p>The Runtime module offers a core collection of utilities intended to support the operational needs of your game during execution:</p> <ul> <li>General:<ul> <li>Provides core runtime functionality for other modules. </li> <li>Defines UObject classes that are widely used by interface classes in other Gorgeous plugins.</li> </ul> </li> <li>Object Variables:<ul> <li>Defines a system for creating and managing variables as objects, including enums, a registry for level switches, and command definitions. </li> <li>Provides base classes and definitions for various types of object variables (single, array, map, set).</li> <li>Includes interfaces for getting and setting object variable values.</li> <li>Offers helper macros to simplify object variable definitions. </li> </ul> </li> <li>Conditional Object Chooser:<ul> <li>Defines a system for selecting object variables based on conditions, including enums and structures. </li> <li>Provides classes for conditional object selection and various types of conditions (boolean, validity, gameplay tag-based). </li> </ul> </li> <li>Functional Structures:<ul> <li>Enables structures to receive <code>PostEditChangeProperty</code> and <code>PreEditChangeProperty</code> events, allowing for more control over property changes in the editor.</li> </ul> </li> </ul>"},{"location":"Runtime/GT-C-Runtime-About/#integration","title":"\ud83d\udee0\ufe0f Integration","text":"<p>To integrate Gorgeous Core into your project, simply add the plugin to your project's Plugins directory.  Then, you can utilize the provided classes and functions in your C++ code. For example:</p> <pre><code>// Example usage\n#include \"GorgeousCoreMinimalShared.h\"\n// ... your code ...\n</code></pre>"},{"location":"Runtime/GT-C-Runtime-About/#configuration-c-only","title":"\u2699\ufe0f Configuration (C++ only)","text":"<p>To configure Gorgeous Core, you need to add \"GorgeousCoreRuntime\" to the PublicDependencyModuleNames/PrivateDependencyModuleNames array in your project's Build.cs file.  This ensures that your project can access the necessary runtime components. \u00a0 </p> <pre><code>PublicDependencyModuleNames.AddRange(new string[] { \"GorgeousCoreRuntime\" });\nPrivateDependencyModuleNames.AddRange(new string[] { \"GorgeousCoreRuntime\" });\n</code></pre>"},{"location":"Runtime/GT-C-Runtime-About/#frequently-asked-questions-faq","title":"\ud83e\udd14 Frequently Asked Questions (FAQ)","text":"<p>Question: What is the purpose of the GorgeousCoreMinimalShared.h header file?</p> <p>Answer: It provides shared definitions for the GorgeousCoreRuntime module while preventing circular dependency issues.  It should only include classes that belong to the GorgeousCoreRuntime module and should not be included within the GorgeousCoreRuntime module itself.</p> <p>Question: How do Object Variables work in Gorgeous Core?</p> <p>Answer: Gorgeous Core's Object Variable system allows you to define variables as UObjects, providing a flexible and extensible way to store and manipulate data.  This system supports various variable types (single, array, map, set) and includes features like network replication, getter/setter interfaces, and dynamic property management. </p>"},{"location":"Runtime/ConditionalObjectChoosers/GT-C-COC-About/","title":"\ud83d\udd0e About Conditional Object Choosers","text":"Short Description <p>The Gorgeous Conditional Object Chooser system provides a mechanism to dynamically select Object Variables based on various condition evaluations, enabling complex decision-making and conditional branching within the Gorgeous Things ecosystem.</p> Long Description <p>The Gorgeous Conditional Object Chooser system enables developers to create sophisticated decision-making components that dynamically select Object Variables based on various conditions. This system allows for flexible and responsive data flow control in Unreal Engine projects.</p> <p>Key features include:</p> <ul> <li>Conditional Selection: Selects Object Variables based on evaluated conditions.</li> <li>Multiple Condition Types: Supports various condition types including Boolean, IsValid, and GameplayTag conditions.</li> <li>Custom Condition Support: Allows for the creation of custom condition types to extend functionality.</li> <li>Blueprint Compatibility: Fully accessible and configurable in both C++ and Blueprint.</li> <li>Integration with Object Variables: Seamlessly works with the Gorgeous Object Variable system.</li> <li>Logic Operations: Supports standard logical operations (AND, OR, XOR, NAND, NOR) and specialized condition checking.</li> <li>Tag-Based Selection: Enables selection based on GameplayTag presence and evaluation.</li> <li>Custom Rule Evaluation: Provides customizable rules for complex selection logic.</li> </ul>"},{"location":"Runtime/ConditionalObjectChoosers/GT-C-COC-About/#frequently-asked-questions-faq","title":"\ud83e\udd14 Frequently Asked Questions (FAQ)","text":"<p>Question: What types of conditions does the Conditional Object Chooser support?</p> <p>Answer: It supports multiple condition types including Boolean conditions (evaluating true/false values), IsValid conditions (checking if object references are valid), and GameplayTag conditions (evaluating based on GameplayTag presence), as well as custom conditions that can be created by extending the base condition class.</p> <p>Question: How does the Conditional Object Chooser relate to the Object Variable system?</p> <p>Answer: The Conditional Object Chooser system works in conjunction with the Object Variable system, allowing for dynamic selection of Object Variables based on specified conditions. It provides a way to branch between different Object Variables based on runtime state.</p> <p>Question: Can I create custom condition types for specific project needs?</p> <p>Answer: Yes, you can create custom conditions by extending the UGorgeousCondition base class and implementing the CheckCondition function to define your own evaluation logic.</p> <p>Question: How are multiple matching conditions handled in the GameplayTag condition?</p> <p>Answer: The GameplayTag condition provides several resolution strategies through the GameplayTagChooserFightMode property, including selecting the first match, last match, a random match, or using a custom rule-based approach defined in the EvaluateCustomRule function.</p>"},{"location":"Runtime/ConditionalObjectChoosers/GT-C-COC-C/","title":"\u2728 Chooser (Blueprint &amp; C++)","text":"Short Description <p>The <code>UGorgeousConditionalObjectChooser</code> class provides a mechanism to select an Object Variable based on specified conditions within the Gorgeous Things ecosystem.</p> Long Description <p><code>UGorgeousConditionalObjectChooser</code> serves as a decision-making component that dynamically selects Object Variables based on condition evaluation. This class enables conditional branching in data flow and object selection, allowing for more complex and responsive systems within the Gorgeous Things framework.</p>"},{"location":"Runtime/ConditionalObjectChoosers/GT-C-COC-C/#features","title":"\ud83d\ude80 Features","text":""},{"location":"Runtime/ConditionalObjectChoosers/GT-C-COC-C/#decidecondition","title":"<code>DecideCondition</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Selects an object variable based on the condition check. This function evaluates the ConditionCheck and returns the appropriate Object Variable from the Conditions array.</p> Output Parameter Type Description <code>ReturnType</code> <code>UGorgeousObjectVariable*</code> The selected Object Variable based on the condition evaluation. Important <p>Ensure that both the <code>ConditionCheck</code> and <code>Conditions</code> array are properly set up before calling this function. If the condition evaluation fails or no matching condition is found, the function might return null.</p> BlueprintC++ <p> Get the selected Object Variable based on condition evaluation. </p> <pre><code>UGorgeousConditionalObjectChooser* ConditionalChooser = ...;\n\n// Get the selected object variable based on condition\nUGorgeousObjectVariable* SelectedVariable = ConditionalChooser-&gt;DecideCondition();\n</code></pre>"},{"location":"Runtime/ConditionalObjectChoosers/GT-C-COC-C/#variable-properties","title":"Variable Properties","text":"Property Type Description <code>ConditionCheck</code> <code>UGorgeousCondition*</code> The condition check object used to determine the selection. <code>Conditions</code> <code>TArray&lt;UGorgeousObjectVariable*&gt;</code> The array of object variables to choose from based on the condition."},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-Boolean-CND/","title":"\u2728 Boolean Condition (Blueprint &amp; C++)","text":"Short Description <p>The <code>UGorgeousBooleanCondition</code> class evaluates boolean values based on a specified mode, providing conditional logic for the Gorgeous Things Conditional Object Chooser system.</p> Long Description <p><code>UGorgeousBooleanCondition</code> extends the base Condition class to provide boolean-specific logic evaluation. This class enables simple Boolean operations between two inputs (A and B) based on the selected conditional mode, allowing for fundamental logic branching within the Gorgeous Things Conditional Object Chooser framework.</p>"},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-Boolean-CND/#features","title":"\ud83d\ude80 Features","text":""},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-Boolean-CND/#checkcondition","title":"<code>CheckCondition</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Evaluates the boolean condition based on the selected mode. This function processes the Boolean inputs A and B according to the specified mode and returns a value indicating the result.</p> Output Parameter Type Description <code>ReturnType</code> <code>uint8</code> Returns 1 if the condition evaluates to true, 0 otherwise based on the mode. Important <p>Ensure that the Boolean inputs A and B are properly initialized before calling this function. The evaluation result depends on the mode selected for the condition.</p> C++ <pre><code>UGorgeousBooleanCondition* BooleanCondition = NewObject&lt;UGorgeousBooleanCondition&gt;();\n\n// Set up the condition\nBooleanCondition-&gt;A = true;\nBooleanCondition-&gt;B = false;\nuint8 Result = BooleanCondition-&gt;CheckCondition();\n</code></pre>"},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-Boolean-CND/#variable-properties","title":"Variable Properties","text":"Property Type Description <code>A</code> <code>bool</code> The first boolean input for the condition evaluation. <code>B</code> <code>bool</code> The second boolean input for the condition evaluation."},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-Boolean-CND/#condition-modes-inherited-from-ugorgeouscondition","title":"Condition Modes (Inherited from UGorgeousCondition)","text":"Mode Description <code>AND</code> Both objects A and B must be valid. <code>OR</code> Either object A or B (or both) must be valid. <code>XOR</code> Either object A or B must be valid, but not both. <code>NAND</code> Both objects A and B must not be valid together. <code>NOR</code> Neither object A nor B can be valid. <code>A_ONLY</code> Only checks if object A is valid. <code>B_ONLY</code> Only checks if object B is valid. <code>N_A_ONLY</code> Only checks if object A is not valid. <code>N_B_ONLY</code> Only checks if object B is not valid."},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-GameplayTag-CND/","title":"\u2728 GameplayTag Condition (Blueprint &amp; C++)","text":"Short Description <p>The <code>UGorgeousGameplayTagCondition</code> class evaluates gameplay tag values based on their appearance in a container, providing a powerful tag-based conditional system within the Gorgeous Things ecosystem.</p> Long Description <p><code>UGorgeousGameplayTagCondition</code> extends the base Condition class to provide gameplay tag-specific logic evaluation. This class allows for dynamic decision-making based on the presence of specific gameplay tags within a referenced container. It supports multiple resolution strategies when multiple matching tags are found, including first match, last match, random selection, or custom rule-based evaluation.</p>"},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-GameplayTag-CND/#features","title":"\ud83d\ude80 Features","text":""},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-GameplayTag-CND/#checkcondition","title":"<code>CheckCondition</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Evaluates the gameplay tag condition based on the selected mode. This function checks for the presence of specified gameplay tags in the container and returns an index value based on the mapping and resolution strategy.</p> Output Parameter Type Description <code>ReturnType</code> <code>uint8</code> Returns the index corresponding to the matched condition based on the gameplay tags. Important <p>Ensure that the <code>GameplayTagContainerClassReference</code> and <code>GameplayTagContainerUPropertyName</code> are properly set to reference a valid gameplay tag container. The return value depends on the <code>GameplayTagConditionMapping</code> and the resolution strategy specified in <code>GameplayTagChooserFightMode</code>.</p> C++ <pre><code>UGorgeousGameplayTagCondition* TagCondition = NewObject&lt;UGorgeousGameplayTagCondition&gt;();\n\n// Set up the condition\nTagCondition-&gt;GameplayTagContainerClassReference = SomeObject;\nTagCondition-&gt;GameplayTagContainerUPropertyName = TEXT(\"MyTagContainer\");\nTagCondition-&gt;GameplayTagChooserFightMode = EConditionalGameplayTagChooserFightMode_E::FIRST;\nuint8 Result = TagCondition-&gt;CheckCondition();\n</code></pre>"},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-GameplayTag-CND/#evaluatecustomrule","title":"<code>EvaluateCustomRule</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Provides a customizable blueprint-implementable method for evaluating which condition should be selected. This function can be overridden in blueprints to implement custom logic for resolving which tag-based condition to select.</p> Output Parameter Type Description <code>ReturnType</code> <code>uint8</code> Returns a valid index for a condition based on custom evaluation logic. Important <p>This function is only called when <code>GameplayTagChooserFightMode</code> is set to <code>RULE</code>. If this function is not implemented in a blueprint child class, it will return 0 by default.</p> Blueprint <p> A blueprint implementation of the custom rule evaluation function. </p>"},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-GameplayTag-CND/#variable-properties","title":"Variable Properties","text":"Property Type Description <code>GameplayTagContainerClassReference</code> <code>UObject*</code> Reference to the class that contains the gameplay tag container property. <code>GameplayTagContainerUPropertyName</code> <code>FName</code> The name of the property that holds the gameplay tag container within the referenced class. <code>GameplayTagConditionMapping</code> <code>TMap&lt;FGameplayTagContainerWrapper_S, int32&gt;</code> Maps gameplay tag containers to condition indices. When a key container's tags are present in the referenced container, its value is returned. <code>GameplayTagChooserFightMode</code> <code>EConditionalGameplayTagChooserFightMode_E</code> Determines how to resolve conflicts when multiple gameplay tags match in the container."},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-GameplayTag-CND/#fight-mode-options","title":"Fight Mode Options","text":"Mode Description <code>FIRST</code> Returns the first matching tag found in the gameplay tag container. <code>LAST</code> Returns the last matching tag found in the gameplay tag container. <code>RANDOM</code> Returns a randomly selected matching tag from the gameplay tag container. <code>RULE</code> Uses the custom rule defined in the <code>EvaluateCustomRule</code> function to determine which tag to select."},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-IsValid-CND/","title":"\u2728 IsValid Condition (Blueprint &amp; C++)","text":"Short Description <p>The <code>UGorgeousIsValidCondition</code> class evaluates object validity (non-null status) to provide conditional selection logic within the Gorgeous Things ecosystem.</p> Long Description <p><code>UGorgeousIsValidCondition</code> extends the base Condition class to provide object validity checking. This class enables decision-making based on whether specified object references are valid (not null), allowing for safer object handling and conditional branching based on object existence within the Gorgeous Things Conditional Object Chooser framework.</p>"},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-IsValid-CND/#features","title":"\ud83d\ude80 Features","text":""},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-IsValid-CND/#checkcondition","title":"<code>CheckCondition</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Checks if the object inputs are valid (not null) based on the selected mode. This function evaluates the validity of objects A and B according to the specified conditional chooser mode and returns a value indicating the result.</p> Output Parameter Type Description <code>ReturnType</code> <code>uint8</code> Returns 1 if the condition evaluates to true, 0 otherwise based on the mode. Important <p>The evaluation is based on the <code>Mode</code> property inherited from <code>UGorgeousCondition</code>, which determines how the validity of objects A and B are combined. For example, if Mode is set to AND, both objects must be valid for the condition to return 1.</p> C++ <pre><code>UGorgeousIsValidCondition* ValidityCondition = NewObject&lt;UGorgeousIsValidCondition&gt;();\n\n// Set up the condition\nValidityCondition-&gt;A = SomeObject;\nValidityCondition-&gt;B = AnotherObject;\nuint8 Result = ValidityCondition-&gt;CheckCondition();\n</code></pre>"},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-IsValid-CND/#variable-properties","title":"Variable Properties","text":"Property Type Description <code>A</code> <code>UObject*</code> The first object input to check for validity. <code>B</code> <code>UObject*</code> The second object input to check for validity."},{"location":"Runtime/ConditionalObjectChoosers/Conditions/GT-C-COC-IsValid-CND/#condition-modes-inherited-from-ugorgeouscondition","title":"Condition Modes (Inherited from UGorgeousCondition)","text":"Mode Description <code>AND</code> Both objects A and B must be valid. <code>OR</code> Either object A or B (or both) must be valid. <code>XOR</code> Either object A or B must be valid, but not both. <code>NAND</code> Both objects A and B must not be valid together. <code>NOR</code> Neither object A nor B can be valid. <code>A_ONLY</code> Only checks if object A is valid. <code>B_ONLY</code> Only checks if object B is valid. <code>N_A_ONLY</code> Only checks if object A is not valid. <code>N_B_ONLY</code> Only checks if object B is not valid."},{"location":"Runtime/ObjectVariables/GT-C-OV-About/","title":"\ud83d\udd0e About Object Variables","text":"Short Description <p>The Gorgeous Object Variable system provides a flexible and extensible way to define variables as objects within the Gorgeous Things ecosystem, supporting various data types and offering features like network replication and dynamic property management. </p> Long Description <p>The Gorgeous Object Variable system allows developers to define variables as UObjects, offering a powerful and organized approach to data storage and manipulation in Unreal Engine. This system supports single variables as well as arrays, maps, and sets, providing a wide range of data structuring capabilities. </p> <p>Key features include:</p> <ul> <li>Base for Object Variables: Serves as the foundation for creating specialized variable types.</li> <li>Dynamic Data Storage: Allows for storing and manipulating various data types as UObjects.</li> <li>Network Replication: Supports network replication for synchronized variable states.</li> <li>Getter and Setter Interfaces: Integrates interfaces for accessing and modifying variable values.</li> <li>Dynamic Property Management: Enables setting and getting properties dynamically using templates.</li> <li>Object Variable Registry: Tracks all active object variables. </li> <li>Persistence: Supports persisting variables across level transitions. </li> <li>Unique Identification: Generates a unique ID for each object variable instance.</li> </ul>"},{"location":"Runtime/ObjectVariables/GT-C-OV-About/#frequently-asked-questions-faq","title":"\ud83e\udd14 Frequently Asked Questions (FAQ)","text":"<p>Question: What types of variables does the Gorgeous Object Variable system support?</p> <p>Answer: It supports single variables, arrays, maps, and sets, allowing for flexible data organization. </p> <p>Question: Does the Object Variable system handle network replication?</p> <p>Answer: Yes, it supports network replication to ensure synchronized variable states across clients.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OV/","title":"\u2728 Object Variable (Blueprint &amp; C++)","text":"Short Description <p>The <code>UGorgeousObjectVariable</code> class is the base class for defining variables as objects within the Gorgeous Things ecosystem. It provides a flexible and extensible way to represent variables as UObjects, supporting single, array, map, and set types.</p> Long Description <p><code>UGorgeousObjectVariable</code> serves as the foundation for creating and managing variables as objects in the Gorgeous Things plugin. This class offers a structured approach to variable handling, enabling dynamic data storage, network replication, and various data organization methods.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OV/#features","title":"\ud83d\ude80 Features","text":""},{"location":"Runtime/ObjectVariables/GT-C-OV-OV/#newobjectvariable","title":"<code>NewObjectVariable</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Constructs a new object variable and registers it within the given registry depending on the parent given.</p> Tip <p>When you set the parent to an object variable that is not the Root Object Variable, you can create a hierarchical structure. This allows you to organize and manage your variables in a tree-like fashion.</p> InputOutput Parameter Type Description <code>Class</code> <code>TSubclassOf&lt;UGorgeousObjectVariable&gt;</code> The class that the object variable should derive from. <code>Parent</code> <code>UGorgeousObjectVariable*</code> The parent of this object variable. The chain can be followed up to the root object variable. <code>bShouldPersist</code> <code>bool</code> Weather this object variable should be persistent across level switches. Parameter Type Description <code>ReturnType</code> <code>UGorgeousObjectVariable*</code> A new variable in object format. <code>Identifier</code> <code>FGuid</code> The unique identifier of the object variable. Important <p>Ensure that the <code>Class</code> is valid before calling this function. Registering a null or invalid class can lead to unexpected behavior and potential crashes.</p> Important <p>Ensure that the <code>Parent</code> pointer is valid before calling this function. Registering a null or invalid pointer can lead to unexpected behavior and potential crashes.</p> BlueprintC++ <p> Register new Object Variable with Root Object Variable as the parent. </p> <pre><code>UGorgeousRootObjectVariable* RootObjectVariable = UGorgeousRootObjectVariable::GetRootObjectVariable();\n\nFGuid MyNewObjectVariableIdentifier;\nUGorgeousObjectVariable* MyNewObjectVariable = RootObjectVariable-&gt;NewObjectVariable(UString_SOV::StaticClass(), MyNewObjectVariableIdentifier, nullptr, false);\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OV/#instantiatetransactionalobjectvariable","title":"<code>InstantiateTransactionalObjectVariable</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Instantiates a new object variable of the specified class as transactional and registers it as a child of the given Parent for persistence across editor sessions.</p> InputOutput Parameter Type Description <code>Class</code> <code>TSubclassOf&lt;UGorgeousObjectVariable&gt;</code> The class of the object variable to instantiate. <code>Parent</code> <code>UGorgeousObjectVariable*</code> The parent of the new instance. Parameter Type Description <code>ReturnType</code> <code>UGorgeousObjectVariable</code> The new transactional instance. Important <p>Ensure that the <code>Class</code> is valid before calling this function. Registering a null or invalid class can lead to unexpected behavior and potential crashes.</p> Important <p>Ensure that the <code>Parent</code> pointer is valid before calling this function. Registering a null or invalid pointer can lead to unexpected behavior and potential crashes.</p> BlueprintC++ <p> Creates a new Transactional Object Variable that persists across editor restarts. </p> <pre><code>UGorgeousRootObjectVariable* RootObjectVariable = UGorgeousRootObjectVariable::GetRootObjectVariable();\n\nFGuid MyNewObjectVariableIdentifier;\nUGorgeousObjectVariable* MyNewObjectVariable = RootObjectVariable-&gt;InstantiateTransactionalObjectVariable(UString_SOV::StaticClass(), nullptr);\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OV/#invokeinstancedfunctionality","title":"<code>InvokeInstancedFunctionality</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Invokes the instanced functionality for when the ObjectVariable is contained inside a UPROPERTY with the Instanced meta specifier.</p> Input Parameter Type Description <code>NewUniqueIdentifier</code> <code>FGuid</code> The new unique identifier. BlueprintC++ <p> Makes an instanced Object Variable that persists inside an outer eligible for the Variable Registry. </p> <pre><code>UGorgeousObjectVariable* MyObjectVariable = ...;\n\nbool OutValue;\nMyObjectVariable-&gt;InvokeInstancedFunctionality(FGuid::NewGuid());\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OV/#registerwithregistry","title":"<code>RegisterWithRegistry</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Registers the object variable with the Gorgeous Core registry. This crucial step ensures that the variable is tracked and managed by the system, allowing it to participate in the Gorgeous Things ecosystem's functionality.</p> Usage <p>This function is typically called internally by the system when a new <code>UGorgeousObjectVariable</code> is created. However, you might need to call it manually in specific scenarios, such as when re-registering a variable after a specific event.</p> Input Parameter Type Description <code>NewObjectVariable</code> <code>TObjectPtr&lt;UGorgeousObjectVariable&gt;</code> A pointer to the object variable instance that needs to be registered. Important <p>Ensure that the <code>NewObjectVariable</code> pointer is valid before calling this function. Registering a null or invalid pointer can lead to unexpected behavior and potential crashes.</p> BlueprintC++ <p> Registers the given Object Variable within the registry of the target object. </p> <pre><code>UGorgeousObjectVariable* RootObjectVariable = UGorgeousRootObjectVariable::GetRootObjectVariable();\n\nRootObjectVariable-&gt;RegisterWithRegistry(MyObjectVariable);\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OV/#setparent","title":"<code>SetParent</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Sets the parent of this object variable. Object variables can be organized in a hierarchy, and this function establishes the parent-child relationship.</p> Input Parameter Type Description <code>NewParent</code> <code>UGorgeousObjectVariable*</code> The new parent of the object variable. Important <p>Ensure that the <code>NewParent</code> pointer is valid before calling this function. Registering a null or invalid pointer can lead to unexpected behavior and potential crashes.</p> BlueprintC++ <p> Reorganizes the hierarchy for a given object variable and sets the given parent as the new one. </p> <pre><code>UGorgeousObjectVariable* MyObjectVariable = ...;\n\nbool OutValue;\nMyObjectVariable-&gt;SetParent(MyNewParent);\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OV/#setdynamicproperty","title":"<code>SetDynamicProperty</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Constructs a new object variable and registers it within the given registry depending on the parent given.</p> Template ParametersInput Parameter Description <code>InTCppType</code> The C++ type of the property. <code>TInPropertyBaseClass</code> The base class of the property. Parameter Type Description <code>PropertyName</code> <code>FName</code> The name of the property to set. <code>Value</code> <code>InTCppType*</code> The value to set. C++ <pre><code>UGorgeousObjectVariable* MyObjectVariable = ...;\n\nMyObjectVariable-&gt;SetDynamicProperty&lt;TArray&lt;bool&gt;, FProperty&gt;(\"SomePropertyName\", false);\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OV/#getdynamicproperty","title":"<code>GetDynamicProperty</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Gets a dynamic property of the object variable at runtime. This function retrieves the value of a property at runtime.</p> Template ParametersInputOutput Parameter Description <code>InTCppType</code> The C++ type of the property. <code>TInPropertyBaseClass</code> The base class of the property. Parameter Type Description <code>PropertyName</code> <code>FName</code> The name of the property to get. Parameter Type Description <code>ReturnType</code> <code>bool</code> True if the property was successfully retrieved, false otherwise. <code>OutValue</code> <code>InTCppType</code> The output value of the property. C++ <pre><code>UGorgeousObjectVariable* MyObjectVariable = ...;\n\nbool OutValue;\nMyObjectVariable-&gt;GetDynamicProperty&lt;bool, FProperty&gt;(\"SomePropertyName\", OutValue);\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OV/#variable-properties","title":"Variable Properties","text":"Property Type Description <code>UniqueIdentifier</code> <code>FGuid</code> A unique identifier for the object variable. <code>VariableRegistry</code> <code>TArray&lt;TObjectPtr&lt;UGorgeousObjectVariable&gt;&gt;</code> The registry of child object variables. <code>bPersistent</code> <code>bool</code> Indicates whether the variable persists across level transitions. <code>Parent</code> <code>UGorgeousObjectVariable*</code> The parent object variable in the hierarchy. Abstract <p>The <code>UE_DEFINE_OBJECT_VARIABLE_*_INTERFACE</code> and <code>UE_DECLARE_OBJECT_VARIABLE_DEFAULT_*_IMPLEMENTATION</code> macros are used to automatically generate getter and setter functions for various variable types (single, array, map, set). They simplify the process of defining how object variables interact with different data types.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/","title":"\u2728 Object Variable Definitions (Blueprint &amp; C++)","text":"Short Description <p>The <code>GorgeousObjectVariableDefinitions.h</code> file defines a comprehensive set of object variable classes that extend the base <code>UGorgeousObjectVariable</code> class. These classes provide specialized implementations for different data types and collection types (single, array, map, set).</p> Long Description <p>The object variable definitions provide a structured way to represent various data types as UObjects within the Gorgeous Things ecosystem. These classes are organized into categories based on their data type and collection type, making it easy to find and use the appropriate variable class for your needs.</p> <p>Each object variable class implements specific interfaces that provide getter and setter functions for the data they store. This allows for consistent access patterns across different variable types and enables easy integration with Blueprints.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#variable-categories","title":"\ud83d\ude80 Variable Categories","text":""},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#base-classes","title":"Base Classes","text":"Class Description <code>USingleObjectVariable</code> Abstract base class for single object variables. <code>UArrayObjectVariable</code> Abstract base class for array object variables. <code>UMapObjectVariable</code> Abstract base class for map object variables. <code>USetObjectVariable</code> Abstract base class for set object variables."},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#object-type-base-classes","title":"Object Type Base Classes","text":"Class Description <code>USingleObjectTypeObjectVariable</code> Abstract base class for single object variables that hold object type values. <code>UArrayObjectTypeObjectVariable</code> Abstract base class for array object variables that hold object type values. <code>UMapObjectTypeObjectVariable</code> Abstract base class for map object variables that hold object type keys. <code>USetObjectTypeObjectVariable</code> Abstract base class for set object variables that hold object type values."},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#single-object-variables","title":"\ud83d\udcca Single Object Variables","text":"<p>Single object variables hold a single value of a specific type.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#object-type-single-variables","title":"Object Type Single Variables","text":"Class Description Value Type <code>UObject_SOTOV</code> Object Single Object Variable <code>UObject*</code> <code>UClass_SOTOV</code> Class Single Object Variable <code>UClass*</code> <code>USoftObject_SOTOV</code> Soft Object Single Object Variable <code>TSoftObjectPtr&lt;UObject&gt;</code> <code>USoftClass_SOTOV</code> Soft Class Single Object Variable <code>TSoftClassPtr&lt;UObject&gt;</code>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#primitive-type-single-variables","title":"Primitive Type Single Variables","text":"Class Description Value Type <code>UBoolean_SOV</code> Boolean Single Object Variable <code>bool</code> <code>UByte_SOV</code> Byte Single Object Variable <code>uint8</code> <code>UFloat_SOV</code> Float Single Object Variable <code>double</code> <code>UInteger64_SOV</code> Integer64 Single Object Variable <code>int64</code> <code>UInteger_SOV</code> Integer Single Object Variable <code>int32</code> <code>UName_SOV</code> Name Single Object Variable <code>FName</code> <code>URotator_SOV</code> Rotator Single Object Variable <code>FRotator</code> <code>UString_SOV</code> String Single Object Variable <code>FString</code> <code>UText_SOV</code> Text Single Object Variable <code>FText</code> <code>UTransform_SOV</code> Transform Single Object Variable <code>FTransform</code> <code>UVector_SOV</code> Vector Single Object Variable <code>FVector</code>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#array-object-variables","title":"\ud83d\udcca Array Object Variables","text":"<p>Array object variables hold an array of values of a specific type.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#object-type-array-variables","title":"Object Type Array Variables","text":"Class Description Value Type <code>UObject_AOTOV</code> Object Array Object Variable <code>TArray&lt;UObject*&gt;</code> <code>UClass_AOTOV</code> Class Array Object Variable <code>TArray&lt;UClass*&gt;</code> <code>USoftObject_AOTOV</code> Soft Object Array Object Variable <code>TArray&lt;TSoftObjectPtr&lt;UObject&gt;&gt;</code> <code>USoftClass_AOTOV</code> Soft Class Array Object Variable <code>TArray&lt;TSoftClassPtr&lt;UObject&gt;&gt;</code>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#primitive-type-array-variables","title":"Primitive Type Array Variables","text":"Class Description Value Type <code>UBoolean_AOV</code> Boolean Array Object Variable <code>TArray&lt;bool&gt;</code> <code>UByte_AOV</code> Byte Array Object Variable <code>TArray&lt;uint8&gt;</code> <code>UFloat_AOV</code> Float Array Object Variable <code>TArray&lt;double&gt;</code> <code>UInteger64_AOV</code> Integer64 Array Object Variable <code>TArray&lt;int64&gt;</code> <code>UInteger_AOV</code> Integer Array Object Variable <code>TArray&lt;int32&gt;</code> <code>UName_AOV</code> Name Array Object Variable <code>TArray&lt;FName&gt;</code> <code>URotator_AOV</code> Rotator Array Object Variable <code>TArray&lt;FRotator&gt;</code> <code>UString_AOV</code> String Array Object Variable <code>TArray&lt;FString&gt;</code> <code>UText_AOV</code> Text Array Object Variable <code>TArray&lt;FText&gt;</code> <code>UTransform_AOV</code> Transform Array Object Variable <code>TArray&lt;FTransform&gt;</code> <code>UVector_AOV</code> Vector Array Object Variable <code>TArray&lt;FVector&gt;</code>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#map-object-variables","title":"\ud83d\udcca Map Object Variables","text":"<p>Map object variables hold a map where the key is of a specific type and the value is a <code>UGorgeousObjectVariable</code>.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#object-type-map-variables","title":"Object Type Map Variables","text":"Class Description Key Type <code>UObject_MOTOV</code> Object Map Object Variable <code>UObject*</code> <code>UClass_MOTOV</code> Class Map Object Variable <code>UClass*</code> <code>USoftObject_MOTOV</code> Soft Object Map Object Variable <code>TSoftObjectPtr&lt;UObject&gt;</code> <code>USoftClass_MOTOV</code> Soft Class Map Object Variable <code>TSoftClassPtr&lt;UObject&gt;</code>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#primitive-type-map-variables","title":"Primitive Type Map Variables","text":"Class Description Key Type <code>UByte_MOV</code> Byte Map Object Variable <code>uint8</code> <code>UFloat_MOV</code> Float Map Object Variable <code>double</code> <code>UInteger64_MOV</code> Integer64 Map Object Variable <code>int64</code> <code>UInteger_MOV</code> Integer Map Object Variable <code>int32</code> <code>UName_MOV</code> Name Map Object Variable <code>FName</code> <code>UString_MOV</code> String Map Object Variable <code>FString</code> <code>UTransform_MOV</code> Transform Map Object Variable <code>FTransform</code> <code>UVector_MOV</code> Vector Map Object Variable <code>FVector</code>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#set-object-variables","title":"\ud83d\udcca Set Object Variables","text":"<p>Set object variables hold a set of values of a specific type.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#object-type-set-variables","title":"Object Type Set Variables","text":"Class Description Value Type <code>UObject_STOTOV</code> Object Set Object Variable <code>TSet&lt;UObject*&gt;</code> <code>UClass_STOTOV</code> Class Set Object Variable <code>TSet&lt;UClass*&gt;</code> <code>USoftObject_STOTOV</code> Soft Object Set Object Variable <code>TSet&lt;TSoftObjectPtr&lt;UObject&gt;&gt;</code> <code>USoftClass_STOTOV</code> Soft Class Set Object Variable <code>TSet&lt;TSoftClassPtr&lt;UObject&gt;&gt;</code>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#primitive-type-set-variables","title":"Primitive Type Set Variables","text":"Class Description Value Type <code>UByte_STOV</code> Byte Set Object Variable <code>TSet&lt;uint8&gt;</code> <code>UFloat_STOV</code> Float Set Object Variable <code>TSet&lt;double&gt;</code> <code>UInteger64_STOV</code> Integer64 Set Object Variable <code>TSet&lt;int64&gt;</code> <code>UInteger_STOV</code> Integer Set Object Variable <code>TSet&lt;int32&gt;</code> <code>UName_STOV</code> Name Set Object Variable <code>TSet&lt;FName&gt;</code> <code>UString_STOV</code> String Set Object Variable <code>TSet&lt;FString&gt;</code> <code>UTransform_STOV</code> Transform Set Object Variable <code>TSet&lt;FTransform&gt;</code> <code>UVector_STOV</code> Vector Set Object Variable <code>TSet&lt;FVector&gt;</code>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#interface-functions","title":"\ud83d\ude80 Interface Functions","text":"<p>Each object variable class implements specific interfaces that provide getter and setter functions for the data they store. These functions are automatically generated using the <code>UE_DEFINE_OBJECT_VARIABLE_*_INTERFACE</code> macros.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#single-object-variable-interface-functions","title":"Single Object Variable Interface Functions","text":""},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#getter-functions","title":"Getter Functions","text":"Function Description Return Type <code>GetObjectVariableSingleObjectVariable</code> Gets a GorgeousObjectVariable <code>UGorgeousObjectVariable*</code> <code>GetObjectObjectSingleObjectVariable</code> Gets a UObject <code>UObject*</code> <code>GetObjectClassSingleObjectVariable</code> Gets a UClass <code>UClass*</code> <code>GetSoftObjectObjectSingleObjectVariable</code> Gets a TSoftObjectPtr <code>TSoftObjectPtr&lt;UObject&gt;</code> <code>GetSoftObjectClassSingleObjectVariable</code> Gets a TSoftClassPtr <code>TSoftClassPtr&lt;UObject&gt;</code> <code>GetBooleanSingleObjectVariable</code> Gets a boolean <code>bool</code> <code>GetByteSingleObjectVariable</code> Gets a byte <code>uint8</code> <code>GetFloatSingleObjectVariable</code> Gets a double <code>double</code> <code>GetInteger64SingleObjectVariable</code> Gets a 64-bit integer <code>int64</code> <code>GetIntegerSingleObjectVariable</code> Gets an integer <code>int32</code> <code>GetNameSingleObjectVariable</code> Gets an FName <code>FName</code> <code>GetRotatorSingleObjectVariable</code> Gets an FRotator <code>FRotator</code> <code>GetStringSingleObjectVariable</code> Gets an FString <code>FString</code> <code>GetTextSingleObjectVariable</code> Gets an FText <code>FText</code> <code>GetTransformSingleObjectVariable</code> Gets an FTransform <code>FTransform</code> <code>GetVectorSingleObjectVariable</code> Gets an FVector <code>FVector</code>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#setter-functions","title":"Setter Functions","text":"Function Description Return Type <code>SetObjectVariableSingleObjectVariable</code> Sets a GorgeousObjectVariable <code>UGorgeousObjectVariable*</code> <code>SetObjectObjectSingleObjectVariable</code> Sets a UObject <code>UObject*</code> <code>SetObjectClassSingleObjectVariable</code> Sets a UClass <code>UClass*</code> <code>SetSoftObjectObjectSingleObjectVariable</code> Sets a TSoftObjectPtr <code>TSoftObjectPtr&lt;UObject&gt;</code> <code>SetSoftObjectClassSingleObjectVariable</code> Sets a TSoftClassPtr <code>TSoftClassPtr&lt;UObject&gt;</code> <code>SetBooleanSingleObjectVariable</code> Sets a boolean <code>bool</code> <code>SetByteSingleObjectVariable</code> Sets a byte <code>uint8</code> <code>SetFloatSingleObjectVariable</code> Sets a double <code>double</code> <code>SetInteger64SingleObjectVariable</code> Sets a 64-bit integer <code>int64</code> <code>SetIntegerSingleObjectVariable</code> Sets an integer <code>int32</code> <code>SetNameSingleObjectVariable</code> Sets an FName <code>FName</code> <code>SetRotatorSingleObjectVariable</code> Sets an FRotator <code>FRotator</code> <code>SetStringSingleObjectVariable</code> Sets an FString <code>FString</code> <code>SetTextSingleObjectVariable</code> Sets an FText <code>FText</code> <code>SetTransformSingleObjectVariable</code> Sets an FTransform <code>FTransform</code> <code>SetVectorSingleObjectVariable</code> Sets an FVector <code>FVector</code>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#array-object-variable-interface-functions","title":"Array Object Variable Interface Functions","text":"<p>Array object variables implement similar getter and setter functions for arrays, with additional functions for array-specific operations such as adding, removing, and finding elements.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#map-object-variable-interface-functions","title":"Map Object Variable Interface Functions","text":"<p>Map object variables implement similar getter and setter functions for maps, with additional functions for map-specific operations such as adding, removing, and finding key-value pairs.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#set-object-variable-interface-functions","title":"Set Object Variable Interface Functions","text":"<p>Set object variables implement similar getter and setter functions for sets, with additional functions for set-specific operations such as adding, removing, and finding elements.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#usage-examples","title":"\ud83d\udcda Usage Examples","text":""},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#creating-and-using-a-single-object-variable","title":"Creating and Using a Single Object Variable","text":"BlueprintC++ <p> Creating and using a String Single Object Variable in Blueprint. </p> <pre><code>// Create a new string object variable\nUGorgeousRootObjectVariable* RootObjectVariable = UGorgeousRootObjectVariable::GetRootObjectVariable();\nFGuid StringVariableIdentifier;\nUGorgeousObjectVariable* StringVariable = RootObjectVariable-&gt;NewObjectVariable(UString_SOV::StaticClass(), StringVariableIdentifier, nullptr, false);\n\n// Set the value\nFString Value = FString(\"Hello, World!\");\nIGorgeousSingleObjectVariablesSetter_I::Execute_SetStringSingleObjectVariable(StringVariable, NAME_None, Value);\n\n// Get the value\nFString RetrievedValue = IGorgeousSingleObjectVariablesGetter_I::Execute_GetStringSingleObjectVariable(StringVariable, NAME_None);\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#creating-and-using-an-array-object-variable","title":"Creating and Using an Array Object Variable","text":"BlueprintC++ <p> Creating and using an Integer Array Object Variable in Blueprint. </p> <pre><code>// Create a new integer array object variable\nUGorgeousRootObjectVariable* RootObjectVariable = UGorgeousRootObjectVariable::GetRootObjectVariable();\nFGuid IntegerArrayVariableIdentifier;\nUGorgeousObjectVariable* IntegerArrayVariable = RootObjectVariable-&gt;NewObjectVariable(UInteger_AOV::StaticClass(), IntegerArrayVariableIdentifier, nullptr, false);\n\n// Set the value\nTArray&lt;int32&gt; Values = {1, 2, 3, 4, 5};\nIGorgeousArrayObjectVariablesSetter_I::Execute_SetIntegerArrayObjectVariable(IntegerArrayVariable, NAME_None, Values);\n\n// Get the value\nTArray&lt;int32&gt; RetrievedValues = IGorgeousArrayObjectVariablesGetter_I::Execute_GetIntegerArrayObjectVariable(IntegerArrayVariable, NAME_None);\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#creating-and-using-a-map-object-variable","title":"Creating and Using a Map Object Variable","text":"BlueprintC++ <p> Creating and using a String Map Object Variable in Blueprint. </p> <pre><code>// Create a new string map object variable\nUGorgeousRootObjectVariable* RootObjectVariable = UGorgeousRootObjectVariable::GetRootObjectVariable();\nFGuid StringMapVariableIdentifier;\nUGorgeousObjectVariable* StringMapVariable = RootObjectVariable-&gt;NewObjectVariable(UString_MOV::StaticClass(), StringMapVariableIdentifier, nullptr, false);\n\n// Set the value\nFGuid MapValueVariableIdentifier;\nUGorgeousObjectVariable* MapValueVariable = RootObjectVariable-&gt;NewObjectVariable(UString_SOV::StaticClass(), MapValueVariableIdentifier, StringMapVariable, false);\nFString MapValue = FString(\"Hello, World!\");\nIGorgeousSingleObjectVariablesSetter_I::Execute_SetStringSingleObjectVariable(MapValueVariable, NAME_None, MapValue);\n\nTMap&lt;FString, UGorgeousObjectVariable*&gt; Value = TMap&lt;FString, UGorgeousObjectVariable*&gt;({\n    { FString(\"Key1\"), MapValueVariable }\n});\nIGorgeousMapObjectVariablesSetter_I::Execute_SetStringMapObjectVariable(StringMapVariable, NAME_None, Value);\n\n// Get the value\nTMap&lt;FString, UGorgeousObjectVariable*&gt; RetrievedMap = IGorgeousMapObjectVariablesGetter_I::Execute_GetStringMapObjectVariable(StringMapVariable, NAME_None);\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#creating-and-using-a-set-object-variable","title":"Creating and Using a Set Object Variable","text":"BlueprintC++ <p> Creating and using a Name Set Object Variable in Blueprint. </p> <pre><code>// Create a new name set object variable\nUGorgeousRootObjectVariable* RootObjectVariable = UGorgeousRootObjectVariable::GetRootObjectVariable();\nFGuid NameSetVariableIdentifier;\nUGorgeousObjectVariable* NameSetVariable = RootObjectVariable-&gt;NewObjectVariable(UName_STOV::StaticClass(), NameSetVariableIdentifier, nullptr, false);\n\n// Set the value\nTSet&lt;FName&gt; Value = TSet&lt;FName&gt;({\n    \"Name1\"\n});\nIGorgeousSetObjectVariablesSetter_I::Execute_SetNameSetObjectVariable(NameSetVariable, NAME_None, Value);\n\n // Get the value\nTSet&lt;FName&gt; RetrievedSet = IGorgeousSetObjectVariablesGetter_I::Execute_GetNameSetObjectVariable(NameSetVariable, NAME_None);\n</code></pre> <p>Tip</p> <p>Specifying the OptionalVariableName variable in any interface Set/Get function, allows you to target not just the default \"Value\" UProperty, but also any UProperty inside the desired UObject that this function is being called on.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#common-properties","title":"\ud83d\udd27 Common Properties","text":"<p>All object variable classes inherit the following properties from <code>UGorgeousObjectVariable</code>:</p> Property Type Description <code>UniqueIdentifier</code> <code>FGuid</code> A unique identifier for the object variable. <code>VariableRegistry</code> <code>TArray&lt;TObjectPtr&lt;UGorgeousObjectVariable&gt;&gt;</code> The registry of child object variables. <code>bPersistent</code> <code>bool</code> Indicates whether the variable persists across level transitions. <code>Parent</code> <code>UGorgeousObjectVariable*</code> The parent object variable in the hierarchy. <p>Each object variable class also has a <code>Value</code> property of the appropriate type for storing the actual data.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-OVD/#implementation-details","title":"\ud83d\udd0d Implementation Details","text":"<p>The object variable classes use the following macros to automatically generate getter and setter functions:</p> <ul> <li><code>UE_DEFINE_OBJECT_VARIABLE_SINGLE_INTERFACE_IMPLEMENTATION</code> - For single object variables</li> <li><code>UE_DEFINE_OBJECT_VARIABLE_MULTIPLE_INTERFACE_IMPLEMENTATION</code> - For array and set object variables</li> <li><code>UE_DEFINE_OBJECT_VARIABLE_MAP_INTERFACE_IMPLEMENTATION</code> - For map object variables</li> </ul> <p>These macros simplify the process of defining how object variables interact with different data types and ensure consistent behavior across all variable types.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-ROV/","title":"\u2728 Root Object Variable (Blueprint &amp; C++)","text":"Short Description <p>The <code>UGorgeousRootObjectVariable</code> class serves as the central registry for all object variables within the Gorgeous Things ecosystem. It implements a singleton pattern for global access and provides comprehensive management of object variables.</p> Long Description <p><code>UGorgeousRootObjectVariable</code> is the foundation of the object variable system in Gorgeous Things. As a singleton, it provides a centralized point of access for all object variables, managing their registration, hierarchy, and lifecycle. This class extends the base <code>UGorgeousObjectVariable</code> class with additional functionality specific to the root registry.</p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-ROV/#features","title":"\ud83d\ude80 Features","text":""},{"location":"Runtime/ObjectVariables/GT-C-OV-ROV/#getrootobjectvariable","title":"<code>GetRootObjectVariable</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Gets the singleton instance of the root object variable, providing global access to the central registry.</p> Output Parameter Type Description <code>ReturnType</code> <code>UGorgeousRootObjectVariable*</code> The singleton instance of the root object variable. Important <p>This function is the primary way to access the root object variable. It ensures that only one instance exists throughout the application lifecycle.</p> BlueprintC++ <p> Get the singleton instance of the Root Object Variable. </p> <pre><code>UGorgeousRootObjectVariable* RootObjectVariable = UGorgeousRootObjectVariable::GetRootObjectVariable();\n\n// Now you can use the root object variable to create new object variables\nFGuid MyNewObjectVariableIdentifier;\nUGorgeousObjectVariable* MyNewObjectVariable = RootObjectVariable-&gt;NewObjectVariable(UString_SOV::StaticClass(), MyNewObjectVariableIdentifier, nullptr, false);\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-ROV/#getvariablehierarchyregistry","title":"<code>GetVariableHierarchyRegistry</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Retrieves the complete hierarchy registry of all object variables, including those nested within other object variables.</p> Output Parameter Type Description <code>ReturnType</code> <code>TArray&lt;UGorgeousObjectVariable*&gt;</code> An array containing all registered object variables in the hierarchy. Important <p>This function returns a flat array of all object variables in the hierarchy, regardless of their nesting level. This is useful for operations that need to process all object variables regardless of their position in the hierarchy.</p> BlueprintC++ <p> Get all object variables in the hierarchy as a flat array. </p> <pre><code>TArray&lt;UGorgeousObjectVariable*&gt; AllVariables = UGorgeousRootObjectVariable::GetVariableHierarchyRegistry();\n\n// Process all variables in the hierarchy\nfor (UGorgeousObjectVariable* Variable : AllVariables)\n{\n    // Do something with each variable\n}\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-ROV/#getrootvariableregistry","title":"<code>GetRootVariableRegistry</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Retrieves the registry of root-level object variables, which are direct children of the root object variable.</p> Output Parameter Type Description <code>ReturnType</code> <code>TArray&lt;UGorgeousObjectVariable*&gt;</code> An array containing all root-level object variables. Important <p>This function returns only the top-level object variables that are direct children of the root object variable. It does not include nested variables.</p> BlueprintC++ <p> Get only the root-level object variables. </p> <pre><code>TArray&lt;UGorgeousObjectVariable*&gt; RootVariables = UGorgeousRootObjectVariable::GetRootVariableRegistry();\n\n// Process only root-level variables\nfor (UGorgeousObjectVariable* Variable : RootVariables)\n{\n    // Do something with each root variable\n}\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-ROV/#removevariablefromregistry","title":"<code>RemoveVariableFromRegistry</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Removes a variable from the registry, effectively unregistering it from the system.</p> Input Parameter Type Description <code>VariableToRemove</code> <code>UGorgeousObjectVariable*</code> The object variable to remove from the registry. Important <p>This function exeutes on both the root registry and the registries of all other variables to properly remove the requested object variable from the whole hierarchy.</p> BlueprintC++ <p> Remove an object variable from the registry. </p> <pre><code>UGorgeousObjectVariable* VariableToRemove = ...;\n\nUGorgeousRootObjectVariable::RemoveVariableFromRegistry(VariableToRemove);\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-ROV/#isvariableregistered","title":"<code>IsVariableRegistered</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Checks if a given object variable is already registered with the registry.</p> InputOutput Parameter Type Description <code>Variable</code> <code>UGorgeousObjectVariable*</code> The variable to check for existence in the registry. Parameter Type Description <code>ReturnType</code> <code>bool</code> True if the variable is registered, false otherwise. Important <p>This function checks both the root registry and the registries of all other variables to determine if the variable is registered anywhere in the hierarchy.</p> BlueprintC++ <p> Check if an object variable is already registered. </p> <pre><code>UGorgeousObjectVariable* MyVariable = ...;\n\nbool bIsRegistered = UGorgeousRootObjectVariable::IsVariableRegistered(MyVariable);\nif (bIsRegistered)\n{\n    // Variable is already registered\n}\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-ROV/#cleanupregistry","title":"<code>CleanupRegistry</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Cleans up the registry, optionally performing a full cleanup.</p> Input Parameter Type Description <code>bFullCleanup</code> <code>bool</code> Whether to perform a full cleanup. Defaults to false. Abstract <p>In most cases you won't even need to call this function, due to that this already happens automatically on every level switch and exit of the game/editor play session.</p> BlueprintC++ <p> Clean up the object variable registry. </p> <pre><code>// Perform a standard cleanup\nUGorgeousRootObjectVariable::CleanupRegistry();\n\n// Or perform a full cleanup\nUGorgeousRootObjectVariable::CleanupRegistry(true);\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-ROV/#setuniversalvariable","title":"<code>SetUniversalVariable</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Sets the value of a property with any type for an object variable identified by its unique identifier.</p> <p>Warning</p> <p>This function is not intended to be called from C++, it should only be used in Blueprint. For a C++ version of this, check out the equivalent SetDynamicProperty function in UGorgeousObjectVariable.</p> Input Parameter Type Description <code>Identifier</code> <code>FGuid</code> The unique identifier of the object variable. <code>OptionalPropertyName</code> <code>FName</code> The name of the property to set. Defaults to \"Value\" if not specified. <code>Value</code> <code>int32</code> The value to set. The actual type depends on the property. Important <p>This function uses a custom thunk to handle different property types. The actual type of the <code>Value</code> parameter will be determined by the property being set.</p> Blueprint <p> Set a property value for an object variable by its identifier. </p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-ROV/#getuniversalvariable","title":"<code>GetUniversalVariable</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Gets the value of a property with any type from an object variable identified by its unique identifier.</p> <p>Warning</p> <p>This function is not intended to be called from C++, it should only be used in Blueprint. For a C++ version of this, check out the equivalent GetDynamicProperty function in UGorgeousObjectVariable.</p> InputOutput Parameter Type Description <code>Identifier</code> <code>FGuid</code> The unique identifier of the object variable. <code>OptionalPropertyName</code> <code>FName</code> The name of the property to get. Defaults to \"Value\" if not specified. Parameter Type Description <code>OutValue</code> <code>int32</code> The output value. The actual type depends on the property. Important <p>This function uses a custom thunk to handle different property types. The actual type of the <code>OutValue</code> parameter will be determined by the property being retrieved.</p> Blueprint <p> Get a property value from an object variable by its identifier. </p>"},{"location":"Runtime/ObjectVariables/GT-C-OV-ROV/#registerwithregistry","title":"<code>RegisterWithRegistry</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>Registers a new object variable with the registry. This is an override of the base class method.</p> Input Parameter Type Description <code>NewObjectVariable</code> <code>UGorgeousObjectVariable*</code> The object variable to register. Usage <p>This function is typically called internally by the system when a new <code>UGorgeousObjectVariable</code> is created. However, you might need to call it manually in specific scenarios, such as when re-registering a variable after a specific event.</p> BlueprintC++ <p> Register a new object variable with the root registry. </p> <pre><code>UGorgeousObjectVariable* MyNewVariable = ...;\n\nUGorgeousRootObjectVariable::GetRootObjectVariable()-&gt;RegisterWithRegistry(MyNewVariable);\n</code></pre>"},{"location":"Runtime/ObjectVariables/GT-C-OV-ROV/#variable-properties","title":"Variable Properties","text":"Property Type Description <code>RootVariableRegistry</code> <code>static TArray&lt;TObjectPtr&lt;UGorgeousObjectVariable&gt;&gt;</code> The registry of root-level object variables. <code>SingletonRootInstance</code> <code>static TObjectPtr&lt;UGorgeousRootObjectVariable&gt;</code> The singleton instance of the root object variable."},{"location":"Runtime/QualityOfLife/GT-C-QOF-GI/","title":"\u2728 Gorgeous Game Instance (Blueprint &amp; C++)","text":"Short Description <p>The <code>UGorgeousGameInstance</code> class extends the standard Unreal Engine <code>UGameInstance</code> by adding an object variable system, allowing you to store and manage persistent data across level transitions and game sessions.</p> Long Description <p><code>UGorgeousGameInstance</code> enhances the standard Unreal Engine <code>UGameInstance</code> by integrating with the Gorgeous Things object variable system. It provides a structured way to store and access persistent data through the <code>AdditionalGorgeousData</code> property, which is a map of named object variables. This allows you to maintain game state, settings, and other important data that needs to persist across level transitions or be globally accessible throughout your game.</p>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-GI/#features","title":"\ud83d\ude80 Features","text":""},{"location":"Runtime/QualityOfLife/GT-C-QOF-GI/#additionalgorgeousdata","title":"<code>AdditionalGorgeousData</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>A map of object variables that extends the standard game instance with persistent data storage capabilities. This property allows you to store various types of data that need to persist across level transitions or be accessible throughout the game.</p> Property Details Property Type Description <code>AdditionalGorgeousData</code> <code>TMap&lt;FName, UGorgeousObjectVariable*&gt;</code> A map of named object variables that store additional data for the game instance. Tip <p>You can use this property to store various types of data, such as: - Cached save game data - Current game settings - Player preferences - Global game state information - Any other data that needs to persist across level transitions</p> Important <p>Each entry in the map is associated with a unique name and is represented by an <code>UGorgeousObjectVariable</code>. When new entries are added in the editor, their <code>UniqueIdentifier</code> is automatically updated.</p> BlueprintC++ <p> Access the AdditionalGorgeousData map in your blueprint. </p> <pre><code>// Accessing data from the AdditionalGorgeousData map\nUGorgeousGameInstance* GameInstance = Cast&lt;UGorgeousGameInstance&gt;(GetWorld()-&gt;GetGameInstance());\nif (GameInstance)\n{\n    // Get a specific object variable by name\n    UGorgeousObjectVariable* MyData = GameInstance-&gt;AdditionalGorgeousData.FindRef(FName(\"MyDataName\"));\n    if (MyData)\n    {\n        // Use the object variable\n        // ...\n    }\n}\n</code></pre>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-GI/#implementation-details","title":"\ud83d\udd27 Implementation Details","text":"<p>The <code>UGorgeousGameInstance</code> class uses several helper macros to simplify its implementation:</p> <ul> <li><code>UE_DECLARE_QOF_CLASS_INIT_INVOKE_ADDITIONAL_DATA</code>: Used in the <code>Init</code> function to initialize the additional data.</li> <li><code>UE_DECLARE_QOF_CLASS_POST_EDIT_CHANGE_PROPERTY</code>: Used to handle property changes in the editor.</li> </ul> <p>These macros are defined in the <code>GorgeousQualityOfLIfeHelperMacros.h</code> file and provide a standardized way to implement common functionality across different classes in the Gorgeous Things ecosystem.</p>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-GI/#integration-with-object-variables","title":"\ud83d\udd04 Integration with Object Variables","text":"<p>The <code>UGorgeousGameInstance</code> class integrates with the Gorgeous Things object variable system, allowing you to store and manage persistent data. This integration provides several benefits:</p> <ol> <li>Persistence: Data stored in object variables persists across level transitions and game sessions.</li> <li>Type Safety: Object variables provide type safety and validation for stored data.</li> <li>Serialization: Object variables can be easily serialized for saving and loading.</li> <li>Network Replication: Object variables support network replication for multiplayer games.</li> </ol> <p>To use this functionality, you need to:</p> <ol> <li>Create a custom game instance class that inherits from <code>UGorgeousGameInstance</code>.</li> <li>Add object variables to the <code>AdditionalGorgeousData</code> map in the editor or at runtime.</li> <li>Access the object variables through the map using their names.</li> </ol>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-GM/","title":"\u2728 Gorgeous Game Mode (Blueprint &amp; C++)","text":"Short Description <p>The <code>AGorgeousGameMode</code> class extends the standard Unreal Engine <code>AGameModeBase</code> by adding an object variable system, allowing you to store and manage game mode-specific data during gameplay.</p> Long Description <p><code>AGorgeousGameMode</code> enhances the standard Unreal Engine <code>AGameModeBase</code> by integrating with the Gorgeous Things object variable system. It provides a structured way to store and access game mode-specific data through the <code>AdditionalGorgeousData</code> property, which is a map of named object variables. This allows you to maintain game mode settings, player data, and other important information that needs to be accessible throughout your game.</p>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-GM/#features","title":"\ud83d\ude80 Features","text":""},{"location":"Runtime/QualityOfLife/GT-C-QOF-GM/#additionalgorgeousdata","title":"<code>AdditionalGorgeousData</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>A map of object variables that extends the standard game mode with persistent data storage capabilities. This property allows you to store various types of data specific to your game mode that need to be accessible during gameplay.</p> Property Details Property Type Description <code>AdditionalGorgeousData</code> <code>TMap&lt;FName, UGorgeousObjectVariable*&gt;</code> A map of named object variables that store additional data for the game mode. Tip <p>You can use this property to store various types of data, such as: - Game mode settings - Player data - Game rules and configurations - Match-specific information - Any other data that needs to be accessible during gameplay</p> Important <p>Each entry in the map is associated with a unique name and is represented by an <code>UGorgeousObjectVariable</code>. When new entries are added in the editor, their <code>UniqueIdentifier</code> is automatically updated.</p> BlueprintC++ <p> Access the AdditionalGorgeousData map in your blueprint. </p> <pre><code>// Accessing data from the AdditionalGorgeousData map\nAGorgeousGameMode* GameMode = Cast&lt;AGorgeousGameMode&gt;(GetWorld()-&gt;GetAuthGameMode());\nif (GameMode)\n{\n    // Get a specific object variable by name\n    UGorgeousObjectVariable* MyData = GameMode-&gt;AdditionalGorgeousData.FindRef(FName(\"MyDataName\"));\n    if (MyData)\n    {\n        // Use the object variable\n        // ...\n    }\n}\n</code></pre>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-GM/#implementation-details","title":"\ud83d\udd27 Implementation Details","text":"<p>The <code>AGorgeousGameMode</code> class uses several helper macros to simplify its implementation:</p> <ul> <li><code>UE_DECLARE_QOF_CLASS_INIT_INVOKE_ADDITIONAL_DATA</code>: Used in the <code>BeginPlay</code> function to initialize the additional data.</li> <li><code>UE_DECLARE_QOF_CLASS_POST_EDIT_CHANGE_PROPERTY</code>: Used to handle property changes in the editor.</li> </ul> <p>These macros are defined in the <code>GorgeousQualityOfLIfeHelperMacros.h</code> file and provide a standardized way to implement common functionality across different classes in the Gorgeous Things ecosystem.</p>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-GM/#integration-with-object-variables","title":"\ud83d\udd04 Integration with Object Variables","text":"<p>The <code>AGorgeousGameMode</code> class integrates with the Gorgeous Things object variable system, allowing you to store and manage game mode-specific data. This integration provides several benefits:</p> <ol> <li>Persistence: Data stored in object variables persists throughout the game session.</li> <li>Type Safety: Object variables provide type safety and validation for stored data.</li> <li>Serialization: Object variables can be easily serialized for saving and loading.</li> <li>Network Replication: Object variables support network replication for multiplayer games.</li> </ol> <p>To use this functionality, you need to:</p> <ol> <li>Create a custom game mode class that inherits from <code>AGorgeousGameMode</code>.</li> <li>Add object variables to the <code>AdditionalGorgeousData</code> map in the editor or at runtime.</li> <li>Access the object variables through the map using their names.</li> </ol>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-GS/","title":"\u2728 Gorgeous Game State (Blueprint &amp; C++)","text":"Short Description <p>The <code>AGorgeousGameState</code> class extends the standard Unreal Engine <code>AGameStateBase</code> by adding an object variable system, allowing you to store and manage game state-specific data during gameplay.</p> Long Description <p><code>AGorgeousGameState</code> enhances the standard Unreal Engine <code>AGameStateBase</code> by integrating with the Gorgeous Things object variable system. It provides a structured way to store and access game state-specific data through the <code>AdditionalGorgeousData</code> property, which is a map of named object variables. This allows you to maintain game state settings, player data, and other important information that needs to be accessible throughout your game.</p>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-GS/#features","title":"\ud83d\ude80 Features","text":""},{"location":"Runtime/QualityOfLife/GT-C-QOF-GS/#additionalgorgeousdata","title":"<code>AdditionalGorgeousData</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>A map of object variables that extends the standard game state with persistent data storage capabilities. This property allows you to store various types of data specific to your game state that need to be accessible during gameplay.</p> Property Details Property Type Description <code>AdditionalGorgeousData</code> <code>TMap&lt;FName, UGorgeousObjectVariable*&gt;</code> A map of named object variables that store additional data for the game state. Tip <p>You can use this property to store various types of data, such as: - Game state settings - Player data - Game rules and configurations - Match-specific information - Any other data that needs to be accessible during gameplay</p> Important <p>Each entry in the map is associated with a unique name and is represented by an <code>UGorgeousObjectVariable</code>. When new entries are added in the editor, their <code>UniqueIdentifier</code> is automatically updated.</p> BlueprintC++ <p> Access the AdditionalGorgeousData map in your blueprint. </p> <pre><code>// Accessing data from the AdditionalGorgeousData map\nAGorgeousGameState* GameState = Cast&lt;AGorgeousGameState&gt;(GetWorld()-&gt;GetGameState());\nif (GameState)\n{\n    // Get a specific object variable by name\n    UGorgeousObjectVariable* MyData = GameState-&gt;AdditionalGorgeousData.FindRef(FName(\"MyDataName\"));\n    if (MyData)\n    {\n        // Use the object variable\n        // ...\n    }\n}\n</code></pre>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-GS/#implementation-details","title":"\ud83d\udd27 Implementation Details","text":"<p>The <code>AGorgeousGameState</code> class uses several helper macros to simplify its implementation:</p> <ul> <li><code>UE_DECLARE_QOF_CLASS_INIT_INVOKE_ADDITIONAL_DATA</code>: Used in the <code>BeginPlay</code> function to initialize the additional data.</li> <li><code>UE_DECLARE_QOF_CLASS_POST_EDIT_CHANGE_PROPERTY</code>: Used to handle property changes in the editor.</li> </ul> <p>These macros are defined in the <code>GorgeousQualityOfLIfeHelperMacros.h</code> file and provide a standardized way to implement common functionality across different classes in the Gorgeous Things ecosystem.</p>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-GS/#integration-with-object-variables","title":"\ud83d\udd04 Integration with Object Variables","text":"<p>The <code>AGorgeousGameState</code> class integrates with the Gorgeous Things object variable system, allowing you to store and manage game state-specific data. This integration provides several benefits:</p> <ol> <li>Persistence: Data stored in object variables persists throughout the game session.</li> <li>Type Safety: Object variables provide type safety and validation for stored data.</li> <li>Serialization: Object variables can be easily serialized for saving and loading.</li> <li>Network Replication: Object variables support network replication for multiplayer games.</li> </ol> <p>To use this functionality, you need to:</p> <ol> <li>Create a custom game state class that inherits from <code>AGorgeousGameState</code>.</li> <li>Add object variables to the <code>AdditionalGorgeousData</code> map in the editor or at runtime.</li> <li>Access the object variables through the map using their names.</li> </ol>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-PC/","title":"\u2728 Gorgeous Player Controller (Blueprint &amp; C++)","text":"Short Description <p>The <code>AGorgeousPlayerController</code> class extends the standard Unreal Engine <code>APlayerController</code> by adding an object variable system, allowing you to store and manage player controller-specific data during gameplay.</p> Long Description <p><code>AGorgeousPlayerController</code> enhances the standard Unreal Engine <code>APlayerController</code> by integrating with the Gorgeous Things object variable system. It provides a structured way to store and access player controller-specific data through the <code>AdditionalGorgeousData</code> property, which is a map of named object variables. This allows you to maintain player controller settings, input configurations, and other important information that needs to be accessible throughout your game.</p>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-PC/#features","title":"\ud83d\ude80 Features","text":""},{"location":"Runtime/QualityOfLife/GT-C-QOF-PC/#additionalgorgeousdata","title":"<code>AdditionalGorgeousData</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>A map of object variables that extends the standard player controller with persistent data storage capabilities. This property allows you to store various types of data specific to your player controller that need to be accessible during gameplay.</p> Property Details Property Type Description <code>AdditionalGorgeousData</code> <code>TMap&lt;FName, UGorgeousObjectVariable*&gt;</code> A map of named object variables that store additional data for the player controller. Tip <p>You can use this property to store various types of data, such as: - Player controller settings - Input configurations - UI preferences - Player-specific gameplay data - Any other data that needs to be accessible during gameplay</p> Important <p>Each entry in the map is associated with a unique name and is represented by an <code>UGorgeousObjectVariable</code>. When new entries are added in the editor, their <code>UniqueIdentifier</code> is automatically updated.</p> BlueprintC++ <p> Access the AdditionalGorgeousData map in your blueprint. </p> <pre><code>// Accessing data from the AdditionalGorgeousData map\nAGorgeousPlayerController* PlayerController = Cast&lt;AGorgeousPlayerController&gt;(GetWorld()-&gt;GetFirstPlayerController());\nif (PlayerController)\n{\n    // Get a specific object variable by name\n    UGorgeousObjectVariable* MyData = PlayerController-&gt;AdditionalGorgeousData.FindRef(FName(\"MyDataName\"));\n    if (MyData)\n    {\n        // Use the object variable\n        // ...\n    }\n}\n</code></pre>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-PC/#implementation-details","title":"\ud83d\udd27 Implementation Details","text":"<p>The <code>AGorgeousPlayerController</code> class uses several helper macros to simplify its implementation:</p> <ul> <li><code>UE_DECLARE_QOF_CLASS_INIT_INVOKE_ADDITIONAL_DATA</code>: Used in the <code>BeginPlay</code> function to initialize the additional data.</li> <li><code>UE_DECLARE_QOF_CLASS_POST_EDIT_CHANGE_PROPERTY</code>: Used to handle property changes in the editor.</li> </ul> <p>These macros are defined in the <code>GorgeousQualityOfLIfeHelperMacros.h</code> file and provide a standardized way to implement common functionality across different classes in the Gorgeous Things ecosystem.</p>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-PC/#integration-with-object-variables","title":"\ud83d\udd04 Integration with Object Variables","text":"<p>The <code>AGorgeousPlayerController</code> class integrates with the Gorgeous Things object variable system, allowing you to store and manage player controller-specific data. This integration provides several benefits:</p> <ol> <li>Persistence: Data stored in object variables persists throughout the game session.</li> <li>Type Safety: Object variables provide type safety and validation for stored data.</li> <li>Serialization: Object variables can be easily serialized for saving and loading.</li> <li>Network Replication: Object variables support network replication for multiplayer games.</li> </ol> <p>To use this functionality, you need to:</p> <ol> <li>Create a custom player controller class that inherits from <code>AGorgeousPlayerController</code>.</li> <li>Add object variables to the <code>AdditionalGorgeousData</code> map in the editor or at runtime.</li> <li>Access the object variables through the map using their names.</li> </ol>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-PS/","title":"\u2728 Gorgeous Player State (Blueprint &amp; C++)","text":"Short Description <p>The <code>AGorgeousPlayerState</code> class extends the standard Unreal Engine <code>APlayerState</code> by adding an object variable system, allowing you to store and manage player state-specific data during gameplay.</p> Long Description <p><code>AGorgeousPlayerState</code> enhances the standard Unreal Engine <code>APlayerState</code> by integrating with the Gorgeous Things object variable system. It provides a structured way to store and access player state-specific data through the <code>AdditionalGorgeousData</code> property, which is a map of named object variables. This allows you to maintain player state settings, player data, and other important information that needs to be accessible throughout your game.</p>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-PS/#features","title":"\ud83d\ude80 Features","text":""},{"location":"Runtime/QualityOfLife/GT-C-QOF-PS/#additionalgorgeousdata","title":"<code>AdditionalGorgeousData</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>A map of object variables that extends the standard player state with persistent data storage capabilities. This property allows you to store various types of data specific to your player state that need to be accessible during gameplay.</p> Property Details Property Type Description <code>AdditionalGorgeousData</code> <code>TMap&lt;FName, UGorgeousObjectVariable*&gt;</code> A map of named object variables that store additional data for the player state. Tip <p>You can use this property to store various types of data, such as: - Player state settings - Player statistics - Player achievements - Player inventory data - Any other data that needs to be accessible during gameplay</p> Important <p>Each entry in the map is associated with a unique name and is represented by an <code>UGorgeousObjectVariable</code>. When new entries are added in the editor, their <code>UniqueIdentifier</code> is automatically updated.</p> BlueprintC++ <p> Access the AdditionalGorgeousData map in your blueprint. </p> <pre><code>// Accessing data from the AdditionalGorgeousData map\nAGorgeousPlayerState* PlayerState = Cast&lt;AGorgeousPlayerState&gt;(GetWorld()-&gt;GetFirstPlayerController()-&gt;PlayerState);\nif (PlayerState)\n{\n    // Get a specific object variable by name\n    UGorgeousObjectVariable* MyData = PlayerState-&gt;AdditionalGorgeousData.FindRef(FName(\"MyDataName\"));\n    if (MyData)\n    {\n        // Use the object variable\n        // ...\n    }\n}\n</code></pre>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-PS/#implementation-details","title":"\ud83d\udd27 Implementation Details","text":"<p>The <code>AGorgeousPlayerState</code> class uses several helper macros to simplify its implementation:</p> <ul> <li><code>UE_DECLARE_QOF_CLASS_INIT_INVOKE_ADDITIONAL_DATA</code>: Used in the <code>BeginPlay</code> function to initialize the additional data.</li> <li><code>UE_DECLARE_QOF_CLASS_POST_EDIT_CHANGE_PROPERTY</code>: Used to handle property changes in the editor.</li> </ul> <p>These macros are defined in the <code>GorgeousQualityOfLIfeHelperMacros.h</code> file and provide a standardized way to implement common functionality across different classes in the Gorgeous Things ecosystem.</p>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-PS/#integration-with-object-variables","title":"\ud83d\udd04 Integration with Object Variables","text":"<p>The <code>AGorgeousPlayerState</code> class integrates with the Gorgeous Things object variable system, allowing you to store and manage player state-specific data. This integration provides several benefits:</p> <ol> <li>Persistence: Data stored in object variables persists throughout the game session.</li> <li>Type Safety: Object variables provide type safety and validation for stored data.</li> <li>Serialization: Object variables can be easily serialized for saving and loading.</li> <li>Network Replication: Object variables support network replication for multiplayer games.</li> </ol> <p>To use this functionality, you need to:</p> <ol> <li>Create a custom player state class that inherits from <code>AGorgeousPlayerState</code>.</li> <li>Add object variables to the <code>AdditionalGorgeousData</code> map in the editor or at runtime.</li> <li>Access the object variables through the map using their names.</li> </ol>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-WS/","title":"\u2728 Gorgeous World Settings (Blueprint &amp; C++)","text":"Short Description <p>The <code>AGorgeousWorldSettings</code> class extends the standard Unreal Engine <code>AWorldSettings</code> by adding an object variable system, allowing you to store and manage world settings-specific data during gameplay.</p> Long Description <p><code>AGorgeousWorldSettings</code> enhances the standard Unreal Engine <code>AWorldSettings</code> by integrating with the Gorgeous Things object variable system. It provides a structured way to store and access world settings-specific data through the <code>AdditionalGorgeousData</code> property, which is a map of named object variables. This allows you to maintain world settings, level configurations, and other important information that needs to be accessible throughout your game.</p>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-WS/#features","title":"\ud83d\ude80 Features","text":""},{"location":"Runtime/QualityOfLife/GT-C-QOF-WS/#additionalgorgeousdata","title":"<code>AdditionalGorgeousData</code>","text":"\ud83d\udcdd Function Details\ud83d\udcda Usage Examples <p>A map of object variables that extends the standard world settings with persistent data storage capabilities. This property allows you to store various types of data specific to your world settings that need to be accessible during gameplay.</p> Property Details Property Type Description <code>AdditionalGorgeousData</code> <code>TMap&lt;FName, UGorgeousObjectVariable*&gt;</code> A map of named object variables that store additional data for the world settings. Tip <p>You can use this property to store various types of data, such as: - World settings configurations - Level-specific data - Environment settings - Lighting configurations - Any other data that needs to be accessible during gameplay</p> Important <p>Each entry in the map is associated with a unique name and is represented by an <code>UGorgeousObjectVariable</code>. When new entries are added in the editor, their <code>UniqueIdentifier</code> is automatically updated.</p> BlueprintC++ <p> Access the AdditionalGorgeousData map in your blueprint. </p> <pre><code>// Accessing data from the AdditionalGorgeousData map\nAGorgeousWorldSettings* WorldSettings = Cast&lt;AGorgeousWorldSettings&gt;(GetWorld()-&gt;GetWorldSettings());\nif (WorldSettings)\n{\n    // Get a specific object variable by name\n    UGorgeousObjectVariable* MyData = WorldSettings-&gt;AdditionalGorgeousData.FindRef(FName(\"MyDataName\"));\n    if (MyData)\n    {\n        // Use the object variable\n        // ...\n    }\n}\n</code></pre>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-WS/#implementation-details","title":"\ud83d\udd27 Implementation Details","text":"<p>The <code>AGorgeousWorldSettings</code> class uses several helper macros to simplify its implementation:</p> <ul> <li><code>UE_DECLARE_QOF_CLASS_INIT_INVOKE_ADDITIONAL_DATA</code>: Used in the <code>BeginPlay</code> function to initialize the additional data.</li> <li><code>UE_DECLARE_QOF_CLASS_POST_EDIT_CHANGE_PROPERTY</code>: Used to handle property changes in the editor.</li> </ul> <p>These macros are defined in the <code>GorgeousQualityOfLIfeHelperMacros.h</code> file and provide a standardized way to implement common functionality across different classes in the Gorgeous Things ecosystem.</p>"},{"location":"Runtime/QualityOfLife/GT-C-QOF-WS/#integration-with-object-variables","title":"\ud83d\udd04 Integration with Object Variables","text":"<p>The <code>AGorgeousWorldSettings</code> class integrates with the Gorgeous Things object variable system, allowing you to store and manage world settings-specific data. This integration provides several benefits:</p> <ol> <li>Persistence: Data stored in object variables persists throughout the game session.</li> <li>Type Safety: Object variables provide type safety and validation for stored data.</li> <li>Serialization: Object variables can be easily serialized for saving and loading.</li> <li>Network Replication: Object variables support network replication for multiplayer games.</li> </ol> <p>To use this functionality, you need to:</p> <ol> <li>Create a custom world settings class that inherits from <code>AGorgeousWorldSettings</code>.</li> <li>Add object variables to the <code>AdditionalGorgeousData</code> map in the editor or at runtime.</li> <li>Access the object variables through the map using their names.</li> </ol>"},{"location":"RuntimeUtilities/GT-C-Runtime_Utilities-About/","title":"\ud83e\udde9 About this Module \ud83e\udde9","text":"Short Description <p>Gorgeous Core is a versatile Unreal Engine plugin that provides essential runtime utilities for enhanced logging, world context access, singleton management, and various helper functions, streamlining development and promoting organized, efficient code.</p> Long Description <p>Gorgeous Core is designed to be a fundamental building block for Unreal Engine projects, offering a collection of essential tools and utilities that address common development challenges. This plugin simplifies complex tasks and promotes best practices, allowing developers to focus on creating compelling gameplay experiences.</p> <p>The Runtime Utilities module offers a collection of tools specifically designed to support the Gorgeous Things plugin family:</p> <ul> <li>General Utilities:<ul> <li>Provides core functionality and interfaces for other Gorgeous Things plugins.</li> <li>Defines enums and a precompiled header for efficient compilation.</li> </ul> </li> <li>Logging:<ul> <li>Offers a Blueprint library for versatile logging, enabling messages with different levels of importance and display options.</li> </ul> </li> <li>Templates:<ul> <li>Includes templates for creating UObjects with world context awareness and for implementing the singleton pattern.</li> </ul> </li> <li>Helpers:<ul> <li>Contains a set of helper functions for common tasks such as:<ul> <li>Converting file paths.</li> <li>Working with directories and files.</li> <li>Handling language localization.</li> <li>String conversions.</li> </ul> </li> <li>Provides macros for:<ul> <li>Defining API endpoints.</li> <li>Checking for plugin existence.</li> <li>Platform-specific code.</li> <li>Engine version compatibility.</li> </ul> </li> </ul> </li> </ul>"},{"location":"RuntimeUtilities/GT-C-Runtime_Utilities-About/#integration","title":"\ud83d\udee0\ufe0f Integration","text":"<p>To integrate Gorgeous Core into your project, simply add the plugin to your project's Plugins directory.  Then, you can utilize the provided classes and functions in your C++ code. For example:</p> <pre><code>// Example usage\n#include \"GorgeousCoreUtilitiesMinimalShared.h\"\n// ... your code ...\n</code></pre>"},{"location":"RuntimeUtilities/GT-C-Runtime_Utilities-About/#configuration-c-only","title":"\u2699\ufe0f Configuration (C++ only)","text":"<p>To configure Gorgeous Core, you need to add \"GorgeousCoreRuntimeUtilities\" to the PublicDependencyModuleNames/PrivateDependencyModuleNames array in your project's Build.cs file.  This ensures that your project can access the necessary runtime components. \u00a0 </p> <pre><code>PublicDependencyModuleNames.AddRange(new string[] { \"GorgeousCoreRuntimeUtilities\" });\nPrivateDependencyModuleNames.AddRange(new string[] { \"GorgeousCoreRuntimeUtilities\" });\n</code></pre>"},{"location":"RuntimeUtilities/GT-C-Runtime_Utilities-About/#frequently-asked-questions-faq","title":"\ud83e\udd14 Frequently Asked Questions (FAQ)","text":"<p>Question: What does the <code>GorgeousSingleton.h</code> template do?</p> <p>Answer: It provides a convenient way to create singleton UObject classes, ensuring only one instance of the class exists. This is useful for manager classes or other objects that need to be globally accessible.</p> <p>Question: How can I use the logging functionality?</p> <p>Answer: The <code>GorgeousLoggingBlueprintFunctionLibrary.h</code> provides Blueprint Callable functions (e.g., <code>LogInformationMessage</code>, <code>LogWarningMessage</code>) to easily log messages with different levels of importance. Also the correct usage of this class is also documented here.</p>"}]}